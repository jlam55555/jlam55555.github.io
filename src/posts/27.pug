extends blogpost

block post
	+codestyle
	p (I'll use the abbreviations FP for functional programming and IP for imperative programming.)

	p These three are topics that seem to be fundamental in FP (at least from my limited experience in Haskell and Scheme) but somewhat foreign in IP. To me, these three concepts are difficult to understand either in what exactly they are or what they achieve (monads and continuations) or in their implementation (macros#[+footnote At least the Scheme syntax for it.]).
	
	p There are already plenty of explanations out there on the web, but I wanted to write down the things I found hardest to understand in a simple way.#[+footnote Another concept I could add to this list is laziness, which has enormous implications but the and motivation for which is intuitive.]

	p These explanations were supposed to be short and sweet, but as I was writing more questions and details came up, as they usually do. So I've given each section a tl;dr for those in a hurry.

	hr
	h4 (First-class (reified)) Continuations
	h5 tl;dr
	p A continuation (at a given point in the code in the IP, or for an expression in the FP sense) can be thought of as the next instruction the code will take, or the expression in which the current expression's value will be used, along with the context of that "next expression," or "continuation of the expression."

	h5 Long version
	p The idea is more natural in the FP sense with expressions. Take the following Scheme code as example (from the recent post about streams):

	+precode('scheme').
		(define (stream-ref s n)
		  ;; get the nth value of a stream
		  (if [zero? n]
		      (stream-car s)
		      (stream-ref (stream-cdr s) (1- n))))

	p Take the expression #[code (stream-car s)]. Its continuation is in the #[code if] expression, whose continuation is the context of whatever calls the procedure #[code stream-ref]. It's easy to say that the continuation of an expression is the expression that calls or uses the value of the expression in question.

	p The continuation also includes its #[em context] -- all of the lexically scoped values that come along with the current expression. Thus, for the following snippet:

	+precode('scheme').
		(let ([x 2] [y 3])
		  (* x (1+ (* y 4))))

	p the continuation of the expression #[code (1+ (* y 4))] is the multiplication expression #[code (* x ...)], with the value #[code 2] bound to #[code x].

	p Now that we have an intuitive idea of an expression's continuation, now what? Well, we can use it as a control flow structure and jump to some continuation.

	p This is different than a C/Assembly label (#[code goto] label, switch #[code case] or #[code default] labels, or the implicit labels used by #[code break] or #[code continue] statements in loops). Those labels are simply branch instructions, and do not capture the context at all, which (among other reasons) makes #[code goto] a bad general programming practice. Other issues with gotos are skipped declarations (which is either an error or very dangerous) and the lack of cross-procedure jumps (which can be achieved with #[code setjmp]/#[code longjmp], but these also don't capture context and should be handled with care).

	p It is more similar to calling a function and returning from that function to the previous function. In this case, we restore the previous context by popping the last stack frame off the stack. In fact, continuations are often used in Scheme to provide non-immediate returns#[+footnote Extending off of this idea, we can use continuations to return from nested procedures without having to rewind the whole stack. Similarly, exception handling control flow can be handled this way, also with the potential to cross procedural boundaries. I used this when I wrote a checkers-playing AI, for example, to easily break out of the DFS when the time limit was up.]. However, continuations are inherently more powerful than a return point for two reasons: they are "multiply-resumable," which means we can call the continuation multiple times; and they are "optionally-resumable," which means that we don't ever have to call them (similar to the implicit labels in a #[code for] loop used for #[code continue] and #[code break]).

	p Because continuations require saving the entire context (call stack), we can think of it as a snapshot of a thread#[+footnote The various wiki pages below note that continuations and threads are roughly equivalent in power, in that they can be used to implement one another. It is left as an exercise to the reader to implement continuations in C using #[code fork()].]. Because it is multiply-resumable, we must save a copy of the thread -- then this thread representation becomes a #[em reification] (concrete implementation) of continuations. Reification is important in order to have first-class continuations as we do in Scheme.

	p In IP languages, we don't typically have a reified version of continuations. We can emulate continuations using lambdas by explicitly passing the continuation of an expression to each of its subexpressions -- this is called #[em continuation-passing style] (CPS), as opposed to the #[em direct style] we are used to. This depends on lambdas capturing their context. Some examples are given in the links below.

	p (Another interesting topic that continuations seem to be useful for is #[em coroutines], but I'm not too familiar with them. See the last link. There is also a famous "yin/yang" problem, which is stated on the Wikipedia page.)

	h5 Implementation
	p We need to first get a handle to a continuation we (might) want to use later using the #[code call/cc] ("call with current continuation"), and then we can "call" that continuation at a later point, which brings us back to that earlier context. The general form is as so:

	+precode('scheme').
		(call/cc
		  (lambda (cc)
		    ...))

	p where #[code cc] is the current continuation (a procedure) of the lambda#[+footnote A regular named procedure taking one argument can be used instead of a lambda, as shown in the next example.]. If we want to use the continuation, then we call #[code cc] with the value we want to send to the current continuation as a value. If we don't call the continuation, then the evaluated value of the lambda will be passed to its continuation as usual. As a very simple example, consider the following nonsensical example (which is basically a nonlocal goto):

	+precode('scheme').
		(define (h x cc)
		  (if [< x 0] (cc -1) 1))

		(define (g x)
		  (1+ (call/cc (lambda (cc) (1+ (h x cc))))))

		(display (g -1))    ; displays 0, calls cc
		(display (g 1))     ; displays 3, doesn't call cc

	p A more illustrative example comes from the Wikipedia page for #[code call/cc]:

	+precode('scheme').
		(define (f return)
		  (return 2)
		  3)

		(display (f (lambda (x) x)))    ; displays 3, doesn't call cc (return)
		(display (call/cc f))           ; displays 2, calls cc (return)

	p It is also easy to see that continuations are first-class: they look just like regular procedures, and can be handled just as any other procedure can be handled.

	h5 References
	ul
		li #[a(href='https://en.wikipedia.org/wiki/Continuation') Wikipedia: Continuation]
		li #[a(href='https://wiki.c2.com/?ContinuationsAreGotos') c2 wiki: Continuations Are Gotos] (the title is misleading, because the article quickly goes into how continuations are not exactly gotos)
		li #[a(href='https://wiki.c2.com/?ContinuationExplanation') c2 wiki: Continuation Explanation]
		li #[a(href='https://wiki.haskell.org/Continuation') Haskell wiki: Continuation] (Haskell has a monad for continuations, which is linked on the wiki page)
		li #[a(href='https://en.wikipedia.org/wiki/Continuation-passing_style') Wikipedia: Continuation-passing style]
		li #[a(href='https://stackoverflow.com/a/612797/2397327') Stack Overflow: What is call/cc?] (an example of continuations in Javascript using CPS)
		li #[a(href='https://ds26gte.github.io/tyscheme/index-Z-H-15.html') Teach Yourself Scheme in Fixnum Days: Jumps] (this has numerous practical examples of #[code call/cc], as well as an explanation of coroutines.).

	hr
	h4 (Syntactic) Macros

	h5 tl;dr
	p Macros are the simplest concept of these three. A macro is a compile-time (preprocessor-time) code rewriting. At the most basic level, as we often see in C/C++, a macro#[+footnote Technically, "macros" in C are preprocessor directives.] can act as a compile-time variable that gets replaced with a constant value. A more complicated version is a macro that takes arguments, which we also see in C/C++. However, while C-style macros give us greater expressive power, they can be dangerous (unhygienic) and only provide basic text-replacement, while macros in Scheme#[+footnote And presumably other FP languages. Template Haskell is an extension for Haskell that allows macros, but I'm not aware of many other FP languages' macro support. An #[a(href='https://softwareengineering.stackexchange.com/a/253377') SWE Stack Exchange post] seems to indicate that Julia and Nim have powerful macro systems.] are syntactic.

	h5 Long version

	p A few general notes about macros before we start talking about Scheme's macros:
	ul
		li Macros don't give us anything new. They just rewrite our source code for us, so that we don't have to write the boring or tricky parts that can be automated. We can do anything we can with macros as we can without macros -- it just would be a pain to do. Think about adding or removing debug code every time you wanted to toggle the debug flag rather than using an #[code ifdef DEBUG] macro in C.
		li C-style macros are already plenty powerful for most purposes, such as systems programming. A lot of the time all you need is simple toggleable flags or text replacement, and we avoid unhygienic macros by following a naming convention. (But we're not here to talk about what works, we're here to talk about what can be.)
		li I used to be confused about when to use (C-style) macros and when to use functions. Macros don't require the overhead of a function call, but they will cause the arguments to be evaluated each time they appear. These make it tricky to choose whether to use a regular procedure or a macro#[+footnote For example, the #[a(href='https://dustri.org/b/min-and-max-macro-considered-harmful.html') common MIN and MAX macros].].
		li Also marginally related to macros are inline functions in C++, which involve the compiler rewriting code for optimization purposes. We also have compiler optimizations that involve code rewrites, including inlining functions or unwrapping loops. This (optimization) is another possible application of macros, but is usually left to the compiler writer, because there's a good chance they know better than you.

	p There are some major problems with C-style #[em lexical] (text-replacement) macros:

	ul
		li Since a macro can output arbitrary text, it can potentially generate malformed code#[+footnote Usually this means we want our macros to generate a semantically-closed code snippet, but there is no way of enforcing this with lexical macros. Syntactic macros enforce semantic closure by default.]. Thus, we can only implement this in compiled-languages, or otherwise risk a runtime error.
		li Our code-rewriting facilities are very weak. Macros use a special preprocessing language that only has a few basic text-replacement commands (e.g., stringifying an argument).
		li Rewriting code simply by text manipulation may be dangerous because there is no information about other symbols in the current scope. Declaring a new symbol whose name shadows another symbol in an outside scope in a macro may involve accidental capturing of an external name. This is the hygiene problem#[+footnote The reason it is called hygienic, from #[a(href='https://wiki.c2.com/?DefineSyntax') c2 wiki: Define Syntax]: "Hygienic means clean or sanitary. Something is hygienic if it does not contaminate unrelated things. For example, surgical practices are hygienic if they do not leave blood and guts lying around to contaminate a wound. Scheme macros are hygienic if they do not affect code outside of their proper scope." This is a nice definition, but I would also add that a simple characterization of a potential hygiene issue is when the macro expansion includes symbols that are not any of its pattern variables.] #[+footnote My basic understanding of hygiene is that it deals with two very similar problems. (Both deal with symbols that are not any of its pattern variables, as mentioned in the previous footnote.) The first is when the symbol is already defined in the macro's lexical scope, in which the macro expansion will bind that value, no matter the lexical scope where the macro is expanded. The second is when the symbol is undefined in the macro's lexical scope, in which a new variable is created to avoid capturing an outside variable. This feels like the GNU "dwim" behavior, which might limit some obscure use cases but generally provides the expected behavior. I could give examples of all three of these but this post is already getting far too long-winded.].

	p The answer to these problems are #[em syntactic] macros#[+footnote Another name for syntactic macros is simply #[em macros] without a qualifier -- this is because Lisp's macros probably predated C's macros, which was originally (and still technically) called the #[em preprocessor]. #[a(href='https://softwareengineering.stackexchange.com/questions/937/why-arent-macros-included-in-most-modern-programming-languages#comment14576_986') Ref].]. These can only generate code that is syntactically correct and closed by (functionally) manipulating the input AST into some valid output AST#[+footnote I say "ostensibly" because (in Scheme at least) the syntax naturally lends itself to an AST representation, and the syntax is only sexprs (lists), so rewriting any list to any other list acts like transforming an AST into another (valid) AST.]. We take as input a list (of valid expressions), and output some other (valid) expression, whether it be an atom or a list. The nice thing about Scheme is that each function call or expression is an ordinary list (homoiconicity), so we naturally output valid Scheme code#[+footnote Of course, even so we can generate semantically incorrect code -- a macro may put a non-function expression as the first element of a list when it should be a function. But this is not a syntactical error, and leads to the ordinary run-time exception that is easy to detect and handle.].

	p Homoiconicity not only addresses the first point (structural/syntactic correctness), but also the second point. Because Lisp is so great for LISt Processing, we can transform Lisp code in arbitrary ways just as if we were transforming an ordinary list. This elevates macros from being a text-replacement tool to an arbitrary compile-time procedure that takes an expression as an argument and returning another expression#[+footnote This can also be emulated at runtime using quoted expressions and then evaluating the transformed expression. This can be the basis for a very basic Lisp metacircular evaluator.].

	p Syntactic macros also allow for hygiene. Hygienic macros were added to the core standard as of R5RS, and Scheme was the first language to implement hygienic macros#[+footnote Of course, the hygiene problem was known for a long time and macro writers had to deal with it. There are several possible solutions listed on the Wikipedia page, but none of them as elegant as automatically supporting hygiene in the language.]. I don't know much about the implementation details#[+footnote The Wikipedia article states that the KFFD algorithm was the first hygienic macro expansion algorithm, but I do not know if that is the one currently in place.], but my understanding is that Scheme macros automatically prevent capture for any local variables.

	p Some examples off the top of my head for macros is to introduce new syntactic constructs ("syntactic sugar") (e.g., list comprehensions, loops), new control flow behavior (delayed evaluation, custom short-circuiting behavior), and attaching metadata to expressions (e.g., automatic differentiation).

	p A quick note about decorators: they also can be thought of as metaprogramming by modifying the behavior of functions or other constructs, but they are (AFAIK) a run-time concept and do not have access to the syntax of the language like macros do. See the SWE Stack Exchange link below about attempting to make Python decorators as powerful as Lisp macros.

	p (I am very interested in macros in other languages, such as Scala and Rust. I am especially interested in the latter and if/how it manages to stay safe and hygienic.)

	h5 Implementation
	p
	| I found that learning the syntax for macros from the standard was abstruse (see
	| #[a(href='http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-12.html#node_sec_9.2') #[!='&#167;']9.2], 
	| #[a(href='http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_sec_11.2.2') #[!='&#167;']11.2.2],
	| #[a(href='http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_sec_11.18') #[!='&#167;']11.18], and 
	| #[a(href='http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_sec_11.19') #[!='&#167;']11.19] from R6RS), and this actually kept me from learning how to use macros for some time. I only started learning how to use macros when I wanted to handle automation differentiation transparently (I never got around to implementing this, but I still do), or when macros are required in order to create lambda expressions for lazily-evaluated streams. The syntax is not actually that hard, and there are plenty of tutorials out there that are better reading than R6RS, but the following is my intuitive understanding of it.

	p The example of lazy streams is very simple. Recall from #[a(href='/blog/25') the post about lazy streams] that we want the stream primitive:

	+precode('scheme').
		(stream-cons a b)

	p to be equivalent to the following:
	+precode('scheme').
		(cons a (lambda () b))

	p We cannot rewrite #[code stream-cons] as an ordinary function because of applicative-order evaluation (the expression #[code b] would be evaluated eagerly). Of course, the user could type out the latter form every time they wanted to use the former, but this makes streams and lazy evaluation a lot less interesting. We want the laziness to be transparent and implicit.

	p In this case, all we need is a simple replacement, and C macros would do just as well in this case because we don't have the hygiene issue. The code for this is:

	+precode('scheme').
		(define-syntax stream-cons
		  ;; have to define as a macro so b is not eagerly evaluated
		  (syntax-rules ()
		    ([_ a b]
		     (cons a (lambda () b)))))

	p There are a few moving parts here. First of all, we have the keyword #[code define-syntax]. Just like with #[define], we bind a value (a syntax transformer created by #[code syntax-rules]) to a name (in this case, #[code stream-cons]). There are also #[code let-syntax] and #[code letrec-syntax], which are analogous to #[code let] and #[code letrec].

	p The #[code syntax-rules] expression looks like the following:

	+precode('scheme').
		(syntax-rules literals (pattern template) ...)

	where #[code literals] is a list of symbols that should only be matched literally. #[code pattern] represents an input expression pattern to match, and #[code template] is the transformed code to emit. We can have multiple patterns-template pairs; the first one that matches the sexpr will be transformed into the corresponding template.

	p In the simple example above, we won't match any literals in the patterns, so #[code literals] is an empty list. We also only have one pattern and template, but there can be multiple patterns in the same way that a #[code cond] statement can have multiple conditions.

	p Just like in C, the use of macros is indistinguisable from a function invocation: the infinite stream of ones, defined by the following:

	+precode('scheme').
		(define ones (stream-cons 1 ones))

	p looks like a function call but it actually gets rewritten to the following:

	+precode('scheme').
		(define ones (cons 1 (lambda () ones)))

	p Here, the pattern #[code (_ a b)] matches with #[code (stream-cons 1 ones)]. Thus, #[code _] matches with #[code stream-cons]#[+footnote The first variable of the pattern always matches the name of the macro, and thus we customarily match it with #[code _] and ignore it.], #[code a] matches with #[code 1], and #[code b] matches with #[code ones]. Of course, #[code a] and #[code b] can be more complicated expressions.

	p I don't think I can do justice to a full explanation of the pattern and template syntax. The easiest way for me to describe patterns is that they are very much like Python's or Javascript's destructuring assignment of (potentially nested) lists#[+footnote Consider the following Javascript snippet: #[code!='[a, [b, c]] = [2, ["Hello, world", [3.14, {foo:"bar"}]]];'] which sets #[code a] to #[code 2], #[code b] to #[code "Hello, world"], and #[code c] to #[code!='[3.14, {foo:"bar"}]'].], except that we can match literals and handle variable-length lists of patterns using the ellipses:
	ul
		li Literals are intuitive. By default, each symbol in the pattern is a #[em pattern variable], which matches an arbitrary expression. A #[em literal variable] is a symbol that appears in the literals list and is only matched by that literal symbol. For example, if you wanted to define a macro #[code bind] that rewrote #[code let] statements with a single binding:
			+precode('scheme').
				(let ([x 4]) (+ x 3))
			p to the following form:
			+precode('scheme').
				(bind (+ x 3) with x <- 4)
			p then #[code bind] might look something like the following#[+footnote While we have a variable binding, note that there is no potential hygiene issue here, since all of the symbols in the template are pattern variables. (Except for #[code let], in which case overwriting #[code let] would both be stupid and be handled correctly due to the hygienic macro.)]:
			+precode('scheme').
				(define-syntax bind
				  (syntax-rules (with <-)
				    ([_ expr with x <- xval]
				     (let ([x xval]) expr))))
			p In this case, the template variables cannot match anything other than #[code with] and #[code <-], clearly. (Note also that #[code x] is a pattern variable and can match any expression, which would throw an error if it is not a simple variable.)

		li Ellipses are extremely powerful but also were extremely confusing to me at first. I could not find any definitions in layman's terms. It took me a day of staring at it to understand what it means. We may naturally consider extending the previous example to an arbitrary number of bindings. For example, the following code:

			+precode('scheme').
				(bind (/ (- (sqrt (- (* b b) (* 4 a c))) b) 2)
				      with (a b c) <- (1 4 4))

			p would be rewritten to:

			+precode('scheme').
				(let ([a 1] [b 4] [c 4])
				  (/ (- (sqrt (- (* b b) (* 4 a c))) b) 2))

			p This can be achieved with the following. Note that the second pattern is the same as the previous example (a special syntax for a single variable), and the third pattern is for the trivial case when there are no variable bindings.

			+precode('scheme').
				(define-syntax bind
				  (syntax-rules (with <-)
				    ([_ expr with (x ...) <- (xval ...)]
				     (let ([x xval] ...) expr))
				    ([_ expr with x <- xval]
				     (let ([x xval]) expr))
				    ([_ expr] expr)))

			p Let's focus on the first pattern-template pair. The pattern is simple enough -- the ellipses indicate that we can take a list of variables #[code (x ...)] and a list of variable value bindings #[code (xval ...)]. Note that:
			ul
				li The pattern cannot be simply #[code (_ expr with x ... <- xval ...)] (with parentheses omitted), because then we have two ellipses in the same list. This can cause ambiguity. I don't have a reference for this, but Scheme doesn't allow me to do this#[+footnote #[a(href='https://stackoverflow.com/a/48192781/2397327') This Stack Overflow answer] suggests that some libraries (in particular Racket's #[code syntax/parse] library do allow for this. I haven't tried it out.]. We can do either #[code (_ expr with (x ...) <- xval ...)] or #[code (_ expr with x ... <- (xval ...))], however, although the imbalance is awkward.
				li The ellipses matches #[em zero or more] occurences of the preceding expression. Because of this, the first rule will successfully match #[code (bind expr with () <- ())]. This may not be what you want -- you may want at least one occurence of the preceeding expression -- the #[a(href='https://www.gnu.org/software/guile/manual/html_node/Syntax-Rules.html') Guile macro documentation] suggests that "a common idiom for this is to name the ellipsized pattern variable with an asterisk."
				li Ellipses always match a (potentially empty) list, while the improper list (see the Guile page) will potentially match #[code cons] expressions that are not proper lists.
				li Ellipses also work within vectors the same as they do with lists.
				li The ellipsized pattern and template have to be structurally equivalent. I can't explain this too well, but the general idea is that, if a certain pattern is repeated twice in an inner expression with an ellipsis, and that inner expression is repeated four times with another ellipsis, then it must also appear eight times in the template. We can somewhat formalize this by saying that each pattern variable in the pattern and expression must have the same count of ellipsis immediately following it or any of its ancestors. This is much better described in the article about "How are ellipses (...) counted during macro expansion?". This article also gives many good examples to practice with.

			p What is super interesting (but also super confusing at first) to me is how ellipsized patterns get transformed into the template (which also necessarily has ellipses, if it uses any of the ellipsized patterns). In this case, we have a generate a list of #[code (x xval)] lists, where #[code x] comes from the #[code (x ...)] ellipsized list and same for #[code xs]. It's a zip function for free! (We can similarly unzip in the reverse way.) The last bulleted note above gives a restriction on the pattern and template in order to enforce this, but it unfortunately doesn't cover the case when the zipped ellipsized lists are not the same length:

			+precode('scheme').
				(bind (+ x y) with (x y) <- (2 3 4)) ;; error!

			p This is also described in the article mentioned above, as well as a restriction on the above rule that allows (potentially ambiguous) expansion of mismatched argument lengths.

	p I've only described the #[code syntax-rules] construct to generate a macro. There is also the more low-level #[code syntax-case]. I personally don't understand how to use it yet (again, the #[a(href='https://www.gnu.org/software/guile/manual/html_node/Syntax-Case.html') (Guile) documentation] is somewhat confusing to me) but we can compare/contrast it with #[code syntax-rules] at a high-level. The first example shown on the Guile documentation is telling:

	+precode('scheme').
		(define-syntax when
		  (syntax-rules ()
		    ((_ test e e* ...)
		     (if test (begin e e* ...)))))

		(define-syntax when
		  (lambda (x)
		    (syntax-case x ()
		      ((_ test e e* ...)
		       #'(if test (begin e e* ...))))))

	p If the two forms are equivalent, this shows that #[code syntax-rules] actually returns a procedure. This makes sense, as we've established that macros are functions mapping code to other code.

	h5 References
	ul
		li #[a(href='https://en.wikibooks.org/wiki/Scheme_Programming/Macros') Wikibooks: Scheme Programming/Macros]
		li #[a(href='https://en.wikipedia.org/wiki/Hygienic_macro') Wikipedia: Hygienic macros]
		li #[a(href='http://community.schemewiki.org/?scheme-faq-macros') scheme-faq-macros] (see the section "How are ellipses (...) 'counted' during macro expansion?")
		li #[a(href='https://wiki.c2.com/?DefineSyntax') c2 wiki: Define Syntax] (the #[code define-syntax] special form in Scheme)
		li #[a(href='https://softwareengineering.stackexchange.com/a/253377') SWE Stack Exchange: How do you make decorators as powerful as macros?] (in Python? The answer: you can't#[+footnote At least not until recently -- #[a(href='https://www.python.org/dev/peps/pep-0638/') PEP 638 -- Syntactic Macros] (Sept. 2020) may change this.].)

	hr
	h4 Monads (and functors, applicatives)
	p TODO: talk about I/O, maybe
	p TODO: talk about optional control flow and return values
	p TODO: talk about expression containers

	h5 References:
	ul
		li #[a(href='https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html') Functors, Applicatives, and Monads in Pictures]
		li #[a(href='https://wiki.haskell.org/All_About_Monads') Haskell wiki: All about Monads]
