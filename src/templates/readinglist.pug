extends layout

block content
    h2 Reading List
    p I.e., the list of "seems like it'll be useful but I'll probably be too busy to ever get around to reading these for real." Some of these are books I own.

    p All of the strange acronyms and silly nicknames are verified. I.e., the books should show up on the first page on Google by searching any of the acronyms provided, meaning that I did not make them up. I do like acronyms though.

    hr
    h3 Pending books/readings
    ul
        li What Color is Your Parachute? (recommended to me to transform the way I think about the job hunt, by my very wise former tech lead)
        li Computer Architecture: A Quantitative Approach (David Patterson's work is very interesting!)
        li Operating Systems Concepts ("The Dinosaur Book")
        li Category Theory for Programmers
        li No Silver Bullet -- Essence and Accident in Software Engineering
        li Introduction to Algorithms -- I have a hardcopy of this
        li The Linux Programming Interface -- I also have a hardcopy of this
        li Advanced Programming in the Unix Environment -- I also have a hardcopy of this
        li Compilers: Principles, Techniques, and Tools ("Dragon Book")
        li FreeBSD Handbook
        li R6RS or R7RS
        li RE4B ("Understanding Assembly Language")
        li CP book
        li Phil Oppermann's osdev guide
        li Modern Operating Systems, 2nd Edition (not modern anymore, but I have a hardcopy)
        li Algorithm Design (I should've read an algorithms book like this a long time ago)
        li Algebra for Applications (wow a math book -- but I do like algebra)
        li TAOCP (long-term goal)
        li Effective Go
        li LYAH
        li The Rustonomicon: The Dark Arts of Unsafe Rust
        li Foundations for Programming Languages

    hr
    h3 In-progress books/readings
    ul
        li Red Book (the database one)
        li Program Analysis book (Draft by CMU profs -- for an independent study)
        li SICP ("Wizard Book") (haven't read the final chapter) -- favorite book of all time -- the (MIT) Scheme equivalent of K&R
        li The Rust Programming Language (TRPL)

    hr
    h3 Finished books/beadings
    ul
        li Thomas's Calculus, 12th edition -- college companion for calc 1-4
        li K&R -- wonderfully terse while showing you around the entirety of ANSI C
        li LYAHFGG -- Playful, a little oblivious of political correctness, but good for the imperative programmer learning Haskell. It takes you on a journey that begins with the usual syntax and semantics, but spirals you into the exponentially-difficult world of type magikery and monads.
        li CTCI (have access to a hardcopy now!)
        li What every programmer should know about memory (#[a(href="/blog/52") it's a fantastic paper overall about understanding memory and memory optimization])

    hr
    h3 Miscellaneous: skills to learn
    ul
        li Typing (limitless fun and accessible)
            li #[strike Colemak (DH mod) (speeeeeed)] learnt Colemak, not DH due to limited availability
            li Dvorak LH (so I can fulfill the unnecessary dream of dual-wielding [keyboards], or just writing with my right hand)
        li
            Programming languages to conquer
            ul
                li Assembly (x86_64/ARM/RISC V) -- RE4B
                li Scala (seems like a good general-purpose language)
                li Rust (lots of cool features, very fast) -- TRPL, The Rustominicon
                li Go (lots of cool features, very fast development) -- Effective Go
                li Haskell (pure functional) -- LYAH
                li CL/elisp (to become truly powerful)
                li Emacs/SLIME (due to the above); also Geiser (like SLIME but for Scheme)
                li JavaScript (this language grows too friggin fast, can't keep up with it)
                li Swift (was recommended to me by my mentor, creator also created LLVM)
                li V (Go syntax/learnibility/compilation speed with Rust runtime performance/no GC)
        li
            Other technologies to conquer
            ul
                li LLVM (obvious reasons)
                li Some HDL (e.g., Verilog/VHDL)
                li Emacs
