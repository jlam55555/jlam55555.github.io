extends layout

block content
    h2 Reading List
    p I.e., the list of "seems like it'll be useful but I'll probably be too busy to ever get around to reading these for real." Some of these are books I own.

    p All of the strange acronyms are verified. I.e., the books should show up on the first page on Google by searching any of the acronyms provided, meaning that I did not make them up. I do like acronyms though.

    ul
        li Compilers ("Dragon Book")
        li FreeBSD Handbook
        li R6RS or R7RS
        li RE4B ("Understanding Assembly Language")
        li CP book
        li Phil Oppermann's osdev guide
        li CTCI (have access to a hardcopy now!)
        li Modern Operating Systems, 2nd Edition (not modern anymore, but I have a hardcopy)
        li Algorithm Design (I should've read an algorithms book like this a long time ago)
        li Algebra for Applications (wow a math book -- but I do like algebra)
        li TAOCP (long-term goal)
        li Effective Go
        li LYAH
        li The Rustonomicon: The Dark Arts of Unsafe Rust
        li Foundations for Programming Languages

    hr
    h3 Books in progress
    ul
        li Red Book (the database one)
        li Program Analysis book (Draft by CMU profs -- for an independent study)
        li SICP ("Wizard Book") (haven't read the final chapter) -- favorite book of all time
        li The Rust Programming Language (TRPL)

    hr
    h3 Books I've actually read (more or less cover-to-cover)
    ul
        li Thomas's Calculus, 12th edition -- college companion for calc 1-4
        li K&R -- wonderfully terse

    hr
    h3 Miscellaneous: skills to learn
    ul
        li Typing (limitless fun and accessible)
            li #[strike Colemak (DH mod) (speeeeeed)] learnt Colemak, not DH due to limited availability
            li Dvorak LH (so I can fulfill the unnecessary dream of dual-wielding [keyboards], or just writing with my right hand)
        li
            Programming languages to conquer
            ul
                li Assembly (x86_64/ARM/RISC V) -- RE4B
                li Scala (seems like a good general-purpose language)
                li Rust (lots of cool features, very fast) -- TRPL, The Rustominicon
                li Go (lots of cool features, very fast development) -- Effective Go
                li Haskell (pure functional) -- LYAH
                li CL/elisp (to become truly powerful)
                li Emacs/SLIME (due to the above); also Geiser (like SLIME but for Scheme)
                li JavaScript (this language grows too friggin fast, can't keep up with it)
                li Swift (was recommended to me by my mentor, creator also created LLVM)
                li V (Go syntax/learnibility/compilation speed with Rust runtime performance/no GC)
        li
            Other technologies to conquer
            ul
                li LLVM (obvious reasons)
                li Some HDL (e.g., Verilog/VHDL)
                li Emacs
