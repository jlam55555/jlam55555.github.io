<!DOCTYPE html><html><head><title>jlam | Continuations, macros, and monads</title><style>html {
	box-sizing: border-box;
	margin: 0;
	padding: 0.5rem;
}
body {
	max-width: 400pt;
	margin: 0 auto;
	padding: 0;
}</style><link rel="icon" href="/res/favicon.png"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><h1>Jonathan Lam</h1><p>Software Engineer @ Google (Pixel TPU)<br>(Recently) EE/CS @ The Cooper Union</p><nav><a href="/">Home</a> | <a href="/contact">Contact</a> | <a href="/experience">Experience</a> | <a href="//github.com/jlam55555/resume/raw/master/resume.pdf" target="_blank">Resume</a> | <a href="/blog">Blog</a></nav><hr><!-- inspiration taken from https://codepen.io/Zoxon/pen/WyqdBb--><!-- styles for blog posts--><style>kbd {
	background-color: #eee;
	padding: 0 3px;
	border: 1px solid black;
	border-radius: 2px;
}
blockquote {
	margin: 0;
	background-color: #eee;
	padding: 1px 1em;
}
li {
	margin-block-start: 1em;
	margin-block-end: 1em;
}
h5 {
	font-size: 1em;
	color: #666;
	margin-bottom: 1em;
}
</style><h2>Blog</h2><h3>Continuations, macros, and monads</h3><p>On 7/12/2021, 7:57:53â€¯PM</p><p><a href="/blog">Return to blog</a></p><hr><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-zc7WDnCM3aom2EziyDIRAtQg1mVXLdILE09Bo+aE1xk0AM2c2cVLfSW9NrxE5tKTX44WBY0Z2HClZ05ur9vB6A==" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" integrity="sha512-vswe+cgvic/XBoF1OcM/TeJ2FW0OofqAVdCZiEYkd6dwGXthvkSFWOoGGJgS2CW70VK5dQM5Oh+7ne47s74VTg==" crossorigin="anonymous"><style>pre {
	padding: .5rem !important;
	line-height: 1 !important;
}
code.fancy-code {
	line-height: 1 !important;
	font-size: 0.75rem !important;
	tab-size: 8 !important;
}
</style><p>(I'll use the abbreviations FP for functional programming and IP for imperative programming.)</p><p>These three are topics that seem to be fundamental in FP (at least from my limited experience in Haskell and Scheme) but somewhat foreign in IP. To me, these three concepts are difficult to understand either in what exactly they are or what they achieve (monads and continuations) or in their implementation (macros<sup id="footnote-1-indicator"><a href="#footnote-1">1</a></sup>).</p><p>There are already plenty of explanations out there on the web, but I wanted to write down the things I found hardest to understand in a simple way.<sup id="footnote-2-indicator"><a href="#footnote-2">2</a></sup></p><p>These explanations were supposed to be short and sweet, but the process of writing this pulled in many questions and additional thoughts (as the writing process usually does, but it the effect was exaggerated by how loaded each of these concepts is). So I've given each section a tl;dr for those in a hurry.</p><hr><h4>(First-class (reified)) Continuations</h4><p><strong>Update 9/6/21</strong>: my final project for the I.S. was about continuations. In the <a href="http://files.lambdalambda.ninja/reports/21_summer/ece491_continuations.pdf">report</a> I go into greater depth exploring the meaning of continuations<sup id="footnote-3-indicator"><a href="#footnote-3">3</a></sup>.</p><h5>tl;dr</h5><p>A continuation (at a given point in the code in the IP, or for an expression in the FP sense) can be thought of as the next instruction the code will take, or the expression in which the current expression's value will be used, along with the context of that "next expression," or "continuation of the expression."</p><h5>Long version</h5><p>The idea is more natural in the FP sense with expressions. Take the following Scheme code as example (from the recent post about streams):</p><pre><code class="fancy-code language-scheme">(define (stream-ref s n)
  ;; get the nth value of a stream
  (if [zero? n]
      (stream-car s)
      (stream-ref (stream-cdr s) (1- n))))
</code></pre><p>Take the expression <code>(stream-car s)</code>. Its continuation is in the <code>if</code> expression, whose continuation is the context of whatever calls the procedure <code>stream-ref</code>. It's easy to say that the continuation of an expression is the expression that calls or uses the value of the expression in question.</p><p>The continuation also includes its <em>context</em> -- all of the lexically scoped values that come along with the current expression. Thus, for the following snippet:</p><pre><code class="fancy-code language-scheme">(let ([x 2] [y 3])
  (* x (1+ (* y 4))))
</code></pre><p>the continuation of the expression <code>(1+ (* y 4))</code> is the multiplication expression <code>(* x ...)</code>, with the value <code>2</code> bound to <code>x</code>.</p><p>Now that we have an intuitive idea of an expression's continuation, now what? Well, we can use it as a control flow structure and jump to some continuation.</p><p>This is different than a C/Assembly label (<code>goto</code> label, switch <code>case</code> or <code>default</code> labels, or the implicit labels used by <code>break</code> or <code>continue</code> statements in loops). Those labels are simply branch instructions, and do not capture the context at all, which (among other reasons) makes <code>goto</code> a bad general programming practice. Other issues with gotos are skipped declarations (which is either an error or very dangerous) and the lack of cross-procedure jumps (which can be achieved with <code>setjmp</code>/<code>longjmp</code>, but these also don't capture context and should be handled with care).</p><p>It is more similar to calling a function and returning from that function to the previous function. In this case, we restore the previous context by popping the last stack frame off the stack. In fact, continuations are often used in Scheme to provide non-immediate returns<sup id="footnote-4-indicator"><a href="#footnote-4">4</a></sup>. However, continuations are inherently more powerful than a return point for two reasons: they are "multiply-resumable," which means we can call the continuation multiple times; and they are "optionally-resumable," which means that we don't ever have to call them (similar to the implicit labels in a <code>for</code> loop used for <code>continue</code> and <code>break</code>).</p><p>Because continuations require saving the entire context (call stack), we can think of it as a snapshot of a thread<sup id="footnote-5-indicator"><a href="#footnote-5">5</a></sup>. Because it is multiply-resumable, we must save a copy of the thread -- then this thread representation becomes a <em>reification</em> (concrete implementation) of continuations. Reification is important in order to have first-class continuations as we do in Scheme.</p><p>In IP languages, we don't typically have a reified version of continuations. We can emulate continuations using lambdas by explicitly passing the continuation of an expression to each of its subexpressions -- this is called <em>continuation-passing style</em> (CPS), as opposed to the <em>direct style</em> we are used to. This depends on lambdas capturing their context. Some examples are given in the links below.</p><p>(Another interesting topic that continuations seem to be useful for is <em>coroutines</em>, but I'm not too familiar with them. See the last link. There is also a famous "yin/yang" problem, which is stated on the Wikipedia page.)</p><h5>Implementation</h5><p>We need to first get a handle to a continuation we (might) want to use later using the <code>call/cc</code> ("call with current continuation"), and then we can "call" that continuation at a later point, which brings us back to that earlier context. The general form is as so:</p><pre><code class="fancy-code language-scheme">(call/cc
  (lambda (cc)
    ...))
</code></pre><p>where <code>cc</code> is the current continuation (a procedure) of the lambda<sup id="footnote-6-indicator"><a href="#footnote-6">6</a></sup>. If we want to use the continuation, then we call <code>cc</code> with the value we want to send to the current continuation as a value. If we don't call the continuation, then the evaluated value of the lambda will be passed to its continuation as usual. As a very simple example, consider the following nonsensical example (which is basically a nonlocal goto):</p><pre><code class="fancy-code language-scheme">(define (h x cc)
  (if [< x 0] (cc -1) 1))

(define (g x)
  (1+ (call/cc (lambda (cc) (1+ (h x cc))))))

(display (g -1))    ; displays 0, calls cc
(display (g 1))     ; displays 3, doesn't call cc
</code></pre><p>A more illustrative example comes from the Wikipedia page for <code>call/cc</code>:</p><pre><code class="fancy-code language-scheme">(define (f return)
  (return 2)
  3)

(display (f (lambda (x) x)))    ; displays 3, doesn't call cc (return)
(display (call/cc f))           ; displays 2, calls cc (return)
</code></pre><p>It is also easy to see that continuations are first-class: they look just like regular procedures, and can be handled just as any other procedure can be handled.</p><h5>References</h5><ul><li><a href="https://en.wikipedia.org/wiki/Continuation">Wikipedia: Continuation</a></li><li><a href="https://wiki.c2.com/?ContinuationsAreGotos">c2 wiki: Continuations Are Gotos</a> (the title is misleading, because the article quickly goes into how continuations are not exactly gotos)</li><li><a href="https://wiki.c2.com/?ContinuationExplanation">c2 wiki: Continuation Explanation</a></li><li><a href="https://wiki.haskell.org/Continuation">Haskell wiki: Continuation</a> (Haskell has a monad for continuations, which is linked on the wiki page)</li><li><a href="https://en.wikipedia.org/wiki/Continuation-passing_style">Wikipedia: Continuation-passing style</a></li><li><a href="https://stackoverflow.com/a/612797/2397327">Stack Overflow: What is call/cc?</a> (an example of continuations in Javascript using CPS)</li><li><a href="https://ds26gte.github.io/tyscheme/index-Z-H-15.html">Teach Yourself Scheme in Fixnum Days: Jumps</a> (this has numerous practical examples of <code>call/cc</code>, as well as an explanation of coroutines.).</li></ul><hr><h4>(Syntactic) Macros</h4><h5>tl;dr</h5><p>Macros are the simplest concept of these three. A macro is a compile-time (preprocessor-time) code rewriting. At the most basic level, as we often see in C/C++, a macro<sup id="footnote-7-indicator"><a href="#footnote-7">7</a></sup> can act as a compile-time variable that gets replaced with a constant value. A more complicated version is a macro that takes arguments, which we also see in C/C++. However, while C-style macros give us greater expressive power, they can be dangerous (unhygienic) and only provide basic text-replacement, while macros in Scheme<sup id="footnote-8-indicator"><a href="#footnote-8">8</a></sup> are syntactic.</p><h5>Long version</h5><p>A few general notes about macros before we start talking about Scheme's macros:</p><ul><li>Macros don't give us anything new. They just rewrite our source code for us, so that we don't have to write the boring or tricky parts that can be automated. We can do anything we can with macros as we can without macros -- it just would be a pain to do. Think about adding or removing debug code every time you wanted to toggle the debug flag rather than using an <code>ifdef DEBUG</code> macro in C.</li><li>C-style macros are already plenty powerful for most purposes, such as systems programming. A lot of the time all you need is simple toggleable flags or text replacement, and we avoid unhygienic macros by following a naming convention. (But we're not here to talk about what works, we're here to talk about what can be.)</li><li>I used to be confused about when to use (C-style) macros and when to use functions. Macros don't require the overhead of a function call, but they will cause the arguments to be evaluated each time they appear. These make it tricky to choose whether to use a regular procedure or a macro<sup id="footnote-9-indicator"><a href="#footnote-9">9</a></sup>.</li><li>Also marginally related to macros are inline functions in C++, which involve the compiler rewriting code for optimization purposes. We also have compiler optimizations that involve code rewrites, including inlining functions or unwrapping loops. This (optimization) is another possible application of macros, but is usually left to the compiler writer, because there's a good chance they know better than you.</li></ul><p>There are some major problems with C-style <em>lexical</em> (text-replacement) macros:</p><ul><li>Since a macro can output arbitrary text, it can potentially generate malformed code<sup id="footnote-10-indicator"><a href="#footnote-10">10</a></sup>. Thus, we can only implement this in compiled-languages, or otherwise risk a runtime error.</li><li>Our code-rewriting facilities are very weak. Macros use a special preprocessing language that only has a few basic text-replacement commands (e.g., stringifying an argument).</li><li>Rewriting code simply by text manipulation may be dangerous because there is no information about other symbols in the current scope. Declaring a new symbol whose name shadows another symbol in an outside scope in a macro may involve accidental capturing of an external name. This is the hygiene problem<sup id="footnote-11-indicator"><a href="#footnote-11">11</a></sup> <sup id="footnote-12-indicator"><a href="#footnote-12">12</a></sup>.</li></ul><p>The answer to these problems are <em>syntactic</em> macros<sup id="footnote-13-indicator"><a href="#footnote-13">13</a></sup>. These can only generate code that is syntactically correct and closed by (functionally) manipulating the input AST into some valid output AST<sup id="footnote-14-indicator"><a href="#footnote-14">14</a></sup>. We take as input a list (of valid expressions), and output some other (valid) expression, whether it be an atom or a list. The nice thing about Scheme is that each function call or expression is an ordinary list (homoiconicity), so we naturally output valid Scheme code<sup id="footnote-15-indicator"><a href="#footnote-15">15</a></sup>.</p><p>Homoiconicity not only addresses the first point (structural/syntactic correctness), but also the second point. Because Lisp is so great for LISt Processing, we can transform Lisp code in arbitrary ways just as if we were transforming an ordinary list. This elevates macros from being a text-replacement tool to an arbitrary compile-time procedure that takes an expression as an argument and returning another expression<sup id="footnote-16-indicator"><a href="#footnote-16">16</a></sup>.</p><p>Syntactic macros also allow for hygiene. Hygienic macros were added to the core standard as of R5RS, and Scheme was the first language to implement hygienic macros<sup id="footnote-17-indicator"><a href="#footnote-17">17</a></sup>. I don't know much about the implementation details<sup id="footnote-18-indicator"><a href="#footnote-18">18</a></sup>, but my understanding is that Scheme macros automatically prevent capture for any local variables.</p><p>Some examples off the top of my head for macros is to introduce new syntactic constructs ("syntactic sugar") (e.g., list comprehensions, loops), new control flow behavior (delayed evaluation, custom short-circuiting behavior), and attaching metadata to expressions (e.g., automatic differentiation).</p><p>A quick note about decorators: they also can be thought of as metaprogramming by modifying the behavior of functions or other constructs, but they are (AFAIK) a run-time concept and do not have access to the syntax of the language like macros do. See the SWE Stack Exchange link below about attempting to make Python decorators as powerful as Lisp macros.</p><p>(I am very interested in macros in other languages, such as Scala and Rust. I am especially interested in the latter and if/how it manages to stay safe and hygienic.)</p><h5>Implementation</h5><p></p>I found that learning the syntax for macros from the standard was abstruse (see
<a href="http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-12.html#node_sec_9.2">&#167;9.2</a>, 
<a href="http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_sec_11.2.2">&#167;11.2.2</a>,
<a href="http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_sec_11.18">&#167;11.18</a>, and 
<a href="http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_sec_11.19">&#167;11.19</a> from R6RS), and this actually kept me from learning how to use macros for some time. I only started learning how to use macros when I wanted to handle automation differentiation transparently (I never got around to implementing this, but I still do), or when macros are required in order to create lambda expressions for lazily-evaluated streams. The syntax is not actually that hard, and there are plenty of tutorials out there that are better reading than R6RS, but the following is my intuitive understanding of it.<p>The example of lazy streams is very simple. Recall from <a href="/blog/25">the post about lazy streams</a> that we want the stream primitive:</p><pre><code class="fancy-code language-scheme">(stream-cons a b)
</code></pre><p>to be equivalent to the following:</p><pre><code class="fancy-code language-scheme">(cons a (lambda () b))
</code></pre><p>We cannot rewrite <code>stream-cons</code> as an ordinary function because of applicative-order evaluation (the expression <code>b</code> would be evaluated eagerly). Of course, the user could type out the latter form every time they wanted to use the former, but this makes streams and lazy evaluation a lot less interesting. We want the laziness to be transparent and implicit.</p><p>In this case, all we need is a simple replacement, and C macros would do just as well in this case because we don't have the hygiene issue. The code for this is:</p><pre><code class="fancy-code language-scheme">(define-syntax stream-cons
  ;; have to define as a macro so b is not eagerly evaluated
  (syntax-rules ()
    ([_ a b]
     (cons a (lambda () b)))))
</code></pre><p>There are a few moving parts here. First of all, we have the keyword <code>define-syntax</code>. Just like with <define></define>, we bind a value (a syntax transformer created by <code>syntax-rules</code>) to a name (in this case, <code>stream-cons</code>). There are also <code>let-syntax</code> and <code>letrec-syntax</code>, which are analogous to <code>let</code> and <code>letrec</code>.</p><p>The <code>syntax-rules</code> expression looks like the following:</p><pre><code class="fancy-code language-scheme">(syntax-rules literals (pattern template) ...)
</code></pre><where><code>literals</code> is a list of symbols that should only be matched literally. <code>pattern</code> represents an input expression pattern to match, and <code>template</code> is the transformed code to emit. We can have multiple patterns-template pairs; the first one that matches the sexpr will be transformed into the corresponding template.</where><p>In the simple example above, we won't match any literals in the patterns, so <code>literals</code> is an empty list. We also only have one pattern and template, but there can be multiple patterns in the same way that a <code>cond</code> statement can have multiple conditions.</p><p>Just like in C, the use of macros is indistinguisable from a function invocation: the infinite stream of ones, defined by the following:</p><pre><code class="fancy-code language-scheme">(define ones (stream-cons 1 ones))
</code></pre><p>looks like a function call but it actually gets rewritten to the following:</p><pre><code class="fancy-code language-scheme">(define ones (cons 1 (lambda () ones)))
</code></pre><p>Here, the pattern <code>(_ a b)</code> matches with <code>(stream-cons 1 ones)</code>. Thus, <code>_</code> matches with <code>stream-cons</code><sup id="footnote-19-indicator"><a href="#footnote-19">19</a></sup>, <code>a</code> matches with <code>1</code>, and <code>b</code> matches with <code>ones</code>. Of course, <code>a</code> and <code>b</code> can be more complicated expressions.</p><p>I don't think I can do justice to a full explanation of the pattern and template syntax. Pattern-matching is common in Haskell, where it is used in every declaration. The easiest way for me to describe patterns to the imperative programmer is that they are very much like Python's or Javascript's destructuring assignment of (potentially nested) lists<sup id="footnote-20-indicator"><a href="#footnote-20">20</a></sup>, except that we can match literals and handle variable-length lists of patterns using the ellipses:</p><ul><li>Literals are intuitive. By default, each symbol in the pattern is a <em>pattern variable</em>, which matches an arbitrary expression. A <em>literal variable</em> is a symbol that appears in the literals list and is only matched by that literal symbol. For example, if you wanted to define a macro <code>bind</code> that rewrote <code>let</code> statements with a single binding:<pre><code class="fancy-code language-scheme">(let ([x 4]) (+ x 3))</code></pre><p>to the following form:</p><pre><code class="fancy-code language-scheme">(bind (+ x 3) with x <- 4)</code></pre><p>then <code>bind</code> might look something like the following<sup id="footnote-21-indicator"><a href="#footnote-21">21</a></sup>:</p><pre><code class="fancy-code language-scheme">(define-syntax bind
  (syntax-rules (with <-)
    ([_ expr with x <- xval]
     (let ([x xval]) expr))))</code></pre><p>In this case, the template variables cannot match anything other than <code>with</code> and <code><-</code>, clearly. (Note also that <code>x</code> is a pattern variable and can match any expression, which would throw an error if it is not a simple variable.)</p></li><li>Ellipses are extremely powerful but also were extremely confusing to me at first. I could not find any definitions in layman's terms. It took me a day of staring at it to understand what it means. We may naturally consider extending the previous example to an arbitrary number of bindings. For example, the following code:<pre><code class="fancy-code language-scheme">(bind (/ (- (sqrt (- (* b b) (* 4 a c))) b) 2)
      with (a b c) <- (1 4 4))
</code></pre><p>would be rewritten to:</p><pre><code class="fancy-code language-scheme">(let ([a 1] [b 4] [c 4])
  (/ (- (sqrt (- (* b b) (* 4 a c))) b) 2))
</code></pre><p>This can be achieved with the following. Note that the second pattern is the same as the previous example (a special syntax for a single variable), and the third pattern is for the trivial case when there are no variable bindings.</p><pre><code class="fancy-code language-scheme">(define-syntax bind
  (syntax-rules (with <-)
    ([_ expr with (x ...) <- (xval ...)]
     (let ([x xval] ...) expr))
    ([_ expr with x <- xval]
     (let ([x xval]) expr))
    ([_ expr] expr)))
</code></pre><p>Let's focus on the first pattern-template pair. The pattern is simple enough -- the ellipses indicate that we can take a list of variables <code>(x ...)</code> and a list of variable value bindings <code>(xval ...)</code>. Note that:</p><ul><li>The pattern cannot be simply <code>(_ expr with x ... <- xval ...)</code> (with parentheses omitted), because then we have two ellipses in the same list. This can cause ambiguity. I don't have a reference for this, but Scheme doesn't allow me to do this<sup id="footnote-22-indicator"><a href="#footnote-22">22</a></sup>. We can do either <code>(_ expr with (x ...) <- xval ...)</code> or <code>(_ expr with x ... <- (xval ...))</code>, however, although the imbalance is awkward.</li><li>The ellipses matches <em>zero or more</em> occurences of the preceding expression. Because of this, the first rule will successfully match <code>(bind expr with () <- ())</code>. This may not be what you want -- you may want at least one occurence of the preceeding expression -- the <a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Rules.html">Guile macro documentation</a> suggests that "a common idiom for this is to name the ellipsized pattern variable with an asterisk."</li><li>Ellipses always match a (potentially empty) list, while the improper list (see the Guile page) will potentially match <code>cons</code> expressions that are not proper lists.</li><li>Ellipses also work within vectors the same as they do with lists.</li><li>The ellipsized pattern and template have to be structurally equivalent. I can't explain this too well, but the general idea is that, if a certain pattern is repeated twice in an inner expression with an ellipsis, and that inner expression is repeated four times with another ellipsis, then it must also appear eight times in the template. We can somewhat formalize this by saying that each pattern variable in the pattern and expression must have the same count of ellipsis immediately following it or any of its ancestors. This is much better described in the article about "How are ellipses (...) counted during macro expansion?". This article also gives many good examples to practice with.</li></ul><p>What is super interesting (but also super confusing at first) to me is how ellipsized patterns get transformed into the template (which also necessarily has ellipses, if it uses any of the ellipsized patterns). In this case, we have a generate a list of <code>(x xval)</code> lists, where <code>x</code> comes from the <code>(x ...)</code> ellipsized list and same for <code>xs</code>. It's a zip function for free! (We can similarly unzip in the reverse way.) The last bulleted note above gives a restriction on the pattern and template in order to enforce this, but it unfortunately doesn't cover the case when the zipped ellipsized lists are not the same length:</p><pre><code class="fancy-code language-scheme">(bind (+ x y) with (x y) <- (2 3 4)) ;; error!
</code></pre><p>This is also described in the article mentioned above, as well as a restriction on the above rule that allows (potentially ambiguous) expansion of mismatched argument lengths.</p></li></ul><p>I've only described the <code>syntax-rules</code> construct to generate a macro. There is also the more low-level <code>syntax-case</code>. I personally don't understand how to use it yet (again, the <a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Case.html">(Guile) documentation</a> is somewhat confusing to me) but we can compare/contrast it with <code>syntax-rules</code> at a high-level. The first example shown on the Guile documentation is telling:</p><pre><code class="fancy-code language-scheme">(define-syntax when
  (syntax-rules ()
    ((_ test e e* ...)
     (if test (begin e e* ...)))))

(define-syntax when
  (lambda (x)
    (syntax-case x ()
      ((_ test e e* ...)
       #'(if test (begin e e* ...))))))
</code></pre><p>If the two forms are equivalent, this shows that <code>syntax-rules</code> actually returns a procedure. This makes sense, as we've established that macros are functions mapping code to other code.</p><h5>References</h5><ul><li><a href="https://en.wikibooks.org/wiki/Scheme_Programming/Macros">Wikibooks: Scheme Programming/Macros</a></li><li><a href="https://en.wikipedia.org/wiki/Hygienic_macro">Wikipedia: Hygienic macros</a></li><li><a href="http://community.schemewiki.org/?scheme-faq-macros">scheme-faq-macros</a> (see the section "How are ellipses (...) 'counted' during macro expansion?")</li><li><a href="https://wiki.c2.com/?DefineSyntax">c2 wiki: Define Syntax</a> (the <code>define-syntax</code> special form in Scheme)</li><li><a href="https://softwareengineering.stackexchange.com/a/253377">SWE Stack Exchange: How do you make decorators as powerful as macros?</a> (in Python? The answer: you can't<sup id="footnote-23-indicator"><a href="#footnote-23">23</a></sup>.)</li></ul><hr><h4>Monads (and functors, applicatives)</h4><p>It will be hard for me to do justice to these three very difficult ideas. I have not really used monads to any significant degree, so I am not sure I am qualified to write this in the first place, but the topic is so fascinatingly pervasive that I had to write about it to some degree. The article "Functors, Applicatives, and Monads in Pictures," and the Stack Overflow answer to "Why are side effects modeled as monads in Haskell?" were very helpful to me. I will defer a long explanation to them and all of the other articles mentioned in the Haskell wiki, and only provide a very high-level overview here with a few concrete examples for motivation.</p><h5>tl;dr</h5><p>If you've ever felt that FP is inherently lacking <em>something</em> that you can do in IP, especially handling non-pure functions, dealing with sequences of statements rather than expressions, or managing state, chances are the solution is monads. Monads offer a catch-all for all non-functional aspects in a functional manner, handling notably difficult concepts such as I/O, PRNGs, sequential or other custom control flows<sup id="footnote-24-indicator"><a href="#footnote-24">24</a></sup>, hashtables, and optional expressions in a uniform way. It also automatically allows us to be aware of any impure behavior in our code because any expression that contains a monad will itself have to be a monadic expression, and its type is indicated as a monadic type.</p><h5>The general idea</h5><p>A monad can be thought of as a wrapper around a value. This wrapper is imbued with certain properties, has to implement the <code>Monad</code> typeclass, and should follow some general laws<sup id="footnote-25-indicator"><a href="#footnote-25">25</a></sup>. This monad "marks" the wrapped result as the result of some impure/nondeterministic computation ("action").</p><p>All a monadic type<sup id="footnote-26-indicator"><a href="#footnote-26">26</a></sup> has to do to implement <code>Monad</code> is to implement the <code>return</code> method, which returns a wrapped monadic version of its input argument, and a method (the <em>bind</em> operator) that takes a monad, a function that converts an unwrapped value to a monadic (wrapped) value (such as <code>return</code>), and returns a monad. It's a little confusing to hear from words alone, so here is a simplified definition of the <code>Monad</code> typeclass:</p><pre><code class="fancy-code language-haskell">class Monad m where
  (>>=)         :: m a -> (a -> m b) -> m b
  return        :: a -> m a
</code></pre><p>This seemingly-obscure bind operator can be interpreted to mean: on the left we have a monad, and on the right we have a function to create another monad using the previous monad. In this way we can "pass" values from one monad to another, allowing us to sequence impure computations by passing the result of one value to the next. A really oversimplified interpretation in Scheme might look something like:</p><pre><code class="fancy-code language-scheme">(define (>>= m1 a->m2)
  (let ([m1-result (monad-get-value m1)])
    ;; can do some logic here with m1-result to produce m1-result'
    (a->m2 m1-result'))
</code></pre><p>Of course, monads are a generic type and the specific logic heavily depends on the monadic type, but this is just to get the idea<sup id="footnote-27-indicator"><a href="#footnote-27">27</a></sup>. A sequence of monadic values essentially translates to a nested <code>let</code> statements. This is nice because it feels more functional: we are expressing a sequence of mutations as a series of nested expressions with the state being passed around as parameters rather than as a global side effect<sup id="footnote-28-indicator"><a href="#footnote-28">28</a></sup>.</p><p>Other nice features of monads are that we can support optional values and control flow with impure values. The former is simply the result of having a container type, and the well-known example is the <code>Maybe</code> monad. The latter allows us to implement all sorts of nice language features, such as continuations, and non-functional data structures, such as hash tables, all within the same neat framework.</p><p>It should also be noted that monads are not a language construct specific to Haskell, but a generic programming design pattern that can be implemented in any language (similar to how continuations can be implemented in any language with lambdas by using CPS). The "Haskell wiki: Monad" article has a section about monad implementations in other languages.</p><h5>The monad hierarchy</h5><p>Monads are a subclass of <em>applicative functors</em> (or simply <em>applicatives</em>), which are themselves a subclass of <em>functors</em>. These are all discussed in the article "Functors, Applicatives, and Monads in Pictures." The (really oversimplified) general idea is that functors are wrapped values on which you can apply a function, applicatives are wrapped values on which you can apply wrapped functions, and monads are wrapped values on which you can apply more general functions that can return other wrapped values<sup id="footnote-29-indicator"><a href="#footnote-29">29</a></sup>.</p><p>From the visual article, I'm able to easily see how applicatives are a subclass of functors, but the hierarchy between applicatives and monads was less clear. This was made clear to me by this <a href="https://stackoverflow.com/a/26194431/2397327">Stack Overflow answer</a>, which states that <code>Applicative</code> and <code>Monad</code> both support the <code>return</code> (monad) or <code>pure</code> (applicative) method as well as the <code>>></code> (monad) or <code>*></code> (applicative) methods, but <code>Monad</code>s have to additionally implement the <code>>>=</code> (bind) operator. The bind operator is a more general version of the <code>>></code> operator that allows you to use the previous wrapped monad value, and thus allows monads to support sequential (chained) operations. To put it even more concretely, here are simplified versions of the <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> typeclasses all next to one another:</p><pre><code class="fancy-code language-haskell">class Functor f where
  fmap          :: (a -> b) -> f a -> f b

class Functor f => Applicative f where
  pure          :: a -> f a
  (<*>)         :: f (a -> b) -> f a -> f b

class Applicative f => Monad f where
  return        :: a -> f a
  (>>=)         :: f a -> (a -> f b) -> f b
</code></pre><p>In particular, we have the following equivalences (copied from the Hackage page on <code>Control.Monad</code>):</p><pre><code class="fancy-code language-haskell">pure            = return
m1 <*> m2       = m1 >>= (x1 -> m2 >>= (x2 -> return (x1 x2)))
(*>)            = (>>)
</code></pre><p>We also have the following default definitions of <code>*></code> (in the <code>Applicative</code> class) and <code>>></code> (in the <code>Monad</code> class) that shows their relationships to <code><*></code>:</p><pre><code class="fancy-code language-haskell">u *> v          = (id <$ u) <*> v
m1 >> m2        = m1 >>= const m2
</code></pre><p>Monads are also a subclass of <em>arrows</em>, which are probably around the same on the hierarchy as applicatives, but not the same. I don't know enough about arrows to talk about them, but they seem to be less popular in Haskell discussions than monads.</p><h5>Examples of monads</h5><p>I've already mentioned a few common types of monads, and I'll mention them here again. The Haskell wiki and the Hackage website have many more examples.</p><p>The stereotypical example of an impure calculation is that which requires input from a human or some other external interface <code>System.IO</code>. Another type of nondeterministic calculation is a random number generator, and this too is a monad <code>Control.Monad.Random.*</code>.</p><p>The list class is a monad. This is actually very intuitive upon inspection of the implementation (taken from <em>Learn you a Haskell</em>):</p><pre><code class="fancy-code language-haskell">instance Functor [] where
  fmap          = map

instance Applicative [] where
  pure x        = [x]
  fs <*> xs     = [f x | f <- fs, x <- xs]

instance Monad [] where
  return x      = [x]
  xs >>= f      = concat (map f xs)
</code></pre><p>The other common example in the introductory study of monads is <code>Data.Maybe</code>, which we've already used many times in examples. This is a data type that wraps an optional value and has custom behavior depending on whether the value is present or not.</p><pre><code class="fancy-code language-haskell">data Maybe a    = Nothing | Just a

instance Functor Maybe where
  fmap f (Just x) = Just (f x)
  fmap f Nothing = Nothing

instance Applicative Maybe where
  pure          = Just
  Nothing <*> _ = Nothing
  (Just f) <*> something = fmap f something

instance Monad Maybe where
  return x      = Just x
  Nothing >>= f = Nothing
  Just x >>= f  = f x
</code></pre><p>Other monads relevant to this discussion include <code>Control.Monad.Reader</code>, <code>Control.Monad.Writer</code>, <code>Data.Hashtable.Class</code> (a typeclass that is based on the <code>Control.Monad.ST</code> monad), and <code>Control.Monad.Cont</code>.</p><h5>References:</h5><ul><li><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, and Monads in Pictures</a></li><li><a href="https://www.haskell.org/tutorial/monads.html">A Gentle Introduction to Haskell: Monads</a></li><li><a href="https://stackoverflow.com/a/2488852/2397327">Stack Overflow: Why are side-effects modeled as monads in Haskell?</a> (the best and simplest explanation I can get to how monads help with impure behavior)</li><li><a href="http://learnyouahaskell.com/a-fistful-of-monads">Learn you a Haskell: A Fistful of Monads</a> (pretty much half of the book LYAH is dedicated to functors, applicative functors, and monads; this section in particular is focused on monads. I haven't read the book yet except for small snippets, but I want to.)</li><li><a href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">You could have invented Monads! (And maybe you already have.)</a></li><li><a href="https://wiki.haskell.org/Monad_laws">Haskell wiki: Monad Laws</a></li><li><a href="https://wiki.haskell.org/All_About_Monads">Haskell wiki: All about Monads</a></li><li><a href="https://wiki.haskell.org/Monad">Haskell wiki: Monad</a> (the section about monads in other languages is interesting, and emphasizes the fact that monads are not a language construct but a program design concept)</li><li><a href="https://wiki.haskell.org/Arrow">Haskell wiki: Arrow</a></li><li><a href="https://stackoverflow.com/q/7220436/2397327">Stack Overflow: Good examples of Not  a Functor/Functor/Applicative/Monad?</a> (a good way to understand the relationships betweeen the structures in the monad hierarchy -- I'm still trying to digest these answers)</li><li><a href="https://stackoverflow.com/q/14576543/2397327">Stack Overflow: Why can applicative functors have side effects, but functors can't?</a> (similar to the previous link)</li><li><a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Monad.html">Hackage: Control.Monad</a></li><li><a href="https://stackoverflow.com/a/17412969/2397327">Stack Overflow: What advantage does a Monad give us over an Applicative?</a> (yet another post on the same topic, because I haven't digested this answer yet either. It interprets monads as separately handling "effects" and "results.")</li></ul><hr><h4>Footnotes</h4><p id="footnote-1"><small><a href="#footnote-1-indicator">1.</a> At least the Scheme syntax for it.</small></p><p id="footnote-2"><small><a href="#footnote-2-indicator">2.</a> Another concept I could add to this list is laziness, which has enormous implications but the and motivation for which is intuitive.</small></p><p id="footnote-3"><small><a href="#footnote-3-indicator">3.</a> I would've put this in a new blog post but there's no easy way to convert LaTeX to this Pug format I'm using.</small></p><p id="footnote-4"><small><a href="#footnote-4-indicator">4.</a> Extending off of this idea, we can use continuations to return from nested procedures without having to rewind the whole stack. Similarly, exception handling control flow can be handled this way, also with the potential to cross procedural boundaries. I used this when I wrote a checkers-playing AI, for example, to easily break out of the DFS when the time limit was up.</small></p><p id="footnote-5"><small><a href="#footnote-5-indicator">5.</a> The various wiki pages below note that continuations and threads are roughly equivalent in power, in that they can be used to implement one another. It is left as an exercise to the reader to implement continuations in C using <code>fork()</code>.</small></p><p id="footnote-6"><small><a href="#footnote-6-indicator">6.</a> A regular named procedure taking one argument can be used instead of a lambda, as shown in the next example.</small></p><p id="footnote-7"><small><a href="#footnote-7-indicator">7.</a> Technically, "macros" in C are preprocessor directives.</small></p><p id="footnote-8"><small><a href="#footnote-8-indicator">8.</a> And presumably other FP languages. Template Haskell is an extension for Haskell that allows macros, but I'm not aware of many other FP languages' macro support. An <a href="https://softwareengineering.stackexchange.com/a/253377">SWE Stack Exchange post</a> seems to indicate that Julia and Nim have powerful macro systems.</small></p><p id="footnote-9"><small><a href="#footnote-9-indicator">9.</a> For example, the <a href="https://dustri.org/b/min-and-max-macro-considered-harmful.html">common MIN and MAX macros</a>.</small></p><p id="footnote-10"><small><a href="#footnote-10-indicator">10.</a> Usually this means we want our macros to generate a semantically-closed code snippet, but there is no way of enforcing this with lexical macros. Syntactic macros enforce semantic closure by default.</small></p><p id="footnote-11"><small><a href="#footnote-11-indicator">11.</a> The reason it is called hygienic, from <a href="https://wiki.c2.com/?DefineSyntax">c2 wiki: Define Syntax</a>: "Hygienic means clean or sanitary. Something is hygienic if it does not contaminate unrelated things. For example, surgical practices are hygienic if they do not leave blood and guts lying around to contaminate a wound. Scheme macros are hygienic if they do not affect code outside of their proper scope." This is a nice definition, but I would also add that a simple characterization of a potential hygiene issue is when the macro expansion includes symbols that are not any of its pattern variables.</small></p><p id="footnote-12"><small><a href="#footnote-12-indicator">12.</a> My basic understanding of hygiene is that it deals with two very similar problems. (Both deal with symbols that are not any of its pattern variables, as mentioned in the previous footnote.) The first is when the symbol is already defined in the macro's lexical scope, in which the macro expansion will bind that value, no matter the lexical scope where the macro is expanded. The second is when the symbol is undefined in the macro's lexical scope, in which a new variable is created to avoid capturing an outside variable. This feels like the GNU "dwim" behavior, which might limit some obscure use cases but generally provides the expected behavior. I could give examples of all three of these but this post is already getting far too long-winded.</small></p><p id="footnote-13"><small><a href="#footnote-13-indicator">13.</a> Another name for syntactic macros is simply <em>macros</em> without a qualifier -- this is because Lisp's macros probably predated C's macros, which was originally (and still technically) called the <em>preprocessor</em>. <a href="https://softwareengineering.stackexchange.com/questions/937/why-arent-macros-included-in-most-modern-programming-languages#comment14576_986">Ref</a>.</small></p><p id="footnote-14"><small><a href="#footnote-14-indicator">14.</a> I say "ostensibly" because (in Scheme at least) the syntax naturally lends itself to an AST representation, and the syntax is only sexprs (lists), so rewriting any list to any other list acts like transforming an AST into another (valid) AST.</small></p><p id="footnote-15"><small><a href="#footnote-15-indicator">15.</a> Of course, even so we can generate semantically incorrect code -- a macro may put a non-function expression as the first element of a list when it should be a function. But this is not a syntactical error, and leads to the ordinary run-time exception that is easy to detect and handle.</small></p><p id="footnote-16"><small><a href="#footnote-16-indicator">16.</a> This can also be emulated at runtime using quoted expressions and then evaluating the transformed expression. This can be the basis for a very basic Lisp metacircular evaluator.</small></p><p id="footnote-17"><small><a href="#footnote-17-indicator">17.</a> Of course, the hygiene problem was known for a long time and macro writers had to deal with it. There are several possible solutions listed on the Wikipedia page, but none of them as elegant as automatically supporting hygiene in the language.</small></p><p id="footnote-18"><small><a href="#footnote-18-indicator">18.</a> The Wikipedia article states that the KFFD algorithm was the first hygienic macro expansion algorithm, but I do not know if that is the one currently in place.</small></p><p id="footnote-19"><small><a href="#footnote-19-indicator">19.</a> The first variable of the pattern always matches the name of the macro, and thus we customarily match it with <code>_</code> and ignore it.</small></p><p id="footnote-20"><small><a href="#footnote-20-indicator">20.</a> Consider the following Javascript snippet: <code>[a, [b, c]] = [2, ["Hello, world", [3.14, {foo:"bar"}]]];</code> which sets <code>a</code> to <code>2</code>, <code>b</code> to <code>"Hello, world"</code>, and <code>c</code> to <code>[3.14, {foo:"bar"}]</code>.</small></p><p id="footnote-21"><small><a href="#footnote-21-indicator">21.</a> While we have a variable binding, note that there is no potential hygiene issue here, since all of the symbols in the template are pattern variables. (Except for <code>let</code>, in which case overwriting <code>let</code> would both be stupid and be handled correctly due to the hygienic macro.)</small></p><p id="footnote-22"><small><a href="#footnote-22-indicator">22.</a> <a href="https://stackoverflow.com/a/48192781/2397327">This Stack Overflow answer</a> suggests that some libraries (in particular Racket's <code>syntax/parse</code> library do allow for this. I haven't tried it out.</small></p><p id="footnote-23"><small><a href="#footnote-23-indicator">23.</a> At least not until recently -- <a href="https://www.python.org/dev/peps/pep-0638/">PEP 638 -- Syntactic Macros</a> (Sept. 2020) may change this.</small></p><p id="footnote-24"><small><a href="#footnote-24-indicator">24.</a> Including continuations, which are not implemented in Haskell as a monad.</small></p><p id="footnote-25"><small><a href="#footnote-25-indicator">25.</a> The monad laws. These are not enforced in Haskell, but they should be followed in order for a monad to have predictable behavior. See link in references.</small></p><p id="footnote-26"><small><a href="#footnote-26-indicator">26.</a> I.e., a concrete implementation of a monad. This must be a parameterized type, i.e., the type constructor must take exactly one parameter, the type of its value -- in other words, a generic container type.</small></p><p id="footnote-27"><small><a href="#footnote-27-indicator">27.</a> Also, as a general reminder, extracting the value of a monad outside of the bind operator <a href="https://stackoverflow.com/a/28708661/2397327">is generally A Bad Idea&trade;</a>. Here, we are extracting the value within the bind operator, which is fine, but usually this would be done by pattern matching rather than an external function like <code>monad-get-value</code>.</small></p><p id="footnote-28"><small><a href="#footnote-28-indicator">28.</a> This is an oversimplified version of the description in "Stack Overflow: Why are side effects modeled as monads in Haskell?" That answer uses a more generic model where we define the type alias <code>type MonadicType m = RealWorld -> (a, RealWorld)</code>. In this case, we pass the global state as a parameter to a monad, and so technically all operations become pure, since we are only operating on our parameters' values. Then again, this model is not perfect, as passing around <code>RealWorld</code> would definitely be dangerous, and (as the comments mention) practical monads like <code>IO</code> <a href="https://stackoverflow.com/questions/2488646/why-are-side-effects-modeled-as-monads-in-haskell/2488852#comment8462421_2488852">support "interaction, concurrency, and nondeterminism"</a> which are not captured by this model. The comments also point to the article: "You could have invented Monads! (And maybe you already have)."</small></p><p id="footnote-29"><small><a href="#footnote-29-indicator">29.</a> An exact distinction and characteristic for the three is very difficult for me to understand at the moment. A better interpretation of wrapped values (see "Stack Overflow: What advantage does a Monad give us over an Applicative?") are some nondeterministic (unpure) computation or action. This action may have some "side effects" or "state" (e.g., in the <code>Maybe</code> applicative, the effect is whether there is a value or not; and a result (e.g., in the <code>Maybe</code> applicative, the result is the value <code>x</code> in <code>Just x</code>). Just by looking at the typeclass definitions for <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code>, we can somewhat see the distinction: <code>fmap</code> only allows us to combine a pure function with a functor to produce another functor; <code><*></code> allows us to combine the results of two actions (the first of which returns a function) into a third action; and <code>>>=</code> allows us to use the result of the first action to generate another action. In other words, functors cannot combine actions; the actions given to an applicative are performed independently and then their results ("sequenced") using <code><*></code> (the "sequencing operator"); and the next action in a monadic sequence can depend on the result of the previous action using the bind operator. The Stack Overflow post gives an example when the <code>Maybe</code> monad and applicative behave differently, in particular because the <code><*></code> operation between <code>Maybe</code>s returns <code>Nothing</code> if any of its operands is <code>Nothing</code>, but in a monad we can introduce a "control flow" such that this is not always the case.</small></p><hr><p>&copy; Copyright 2023 Jonathan Lam</p></body></html>