<!DOCTYPE html><html><head><title>jlam | Continuations, macros, and monads</title><style>html {
	box-sizing: border-box;
	margin: 0;
	padding: 0.5rem;
}
body {
	max-width: 400pt;
	margin: 0 auto;
	padding: 0;
}</style><link rel="icon" href="/res/favicon.png"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><h1>Jonathan Lam</h1><p>EE/CS @ The Cooper Union</p><nav><a href="/">Home</a> | <a href="/contact">Contact</a> | <a href="/experience">Experience</a> | <a href="/res/resume.pdf" target="_blank">Resume</a> | <a href="http://files.lambdalambda.ninja">Files</a> | <a href="/blog">Blog</a></nav><hr><!-- inspiration taken from https://codepen.io/Zoxon/pen/WyqdBb--><!-- styles for blog posts--><style>kbd {
	background-color: #eee;
	padding: 0 3px;
	border: 1px solid black;
	border-radius: 2px;
}
blockquote {
	margin: 0;
	background-color: #eee;
	padding: 1px 1em;
}
li {
	margin-block-start: 1em;
	margin-block-end: 1em;
}
h5 {
	font-size: 1em;
	color: #666;
	margin-bottom: 1em;
}
</style><h2>Blog</h2><h3>Continuations, macros, and monads</h3><p>On 7/12/2021, 10:57:53 PM</p><p><a href="/blog">Return to blog</a></p><hr><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-zc7WDnCM3aom2EziyDIRAtQg1mVXLdILE09Bo+aE1xk0AM2c2cVLfSW9NrxE5tKTX44WBY0Z2HClZ05ur9vB6A==" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" integrity="sha512-vswe+cgvic/XBoF1OcM/TeJ2FW0OofqAVdCZiEYkd6dwGXthvkSFWOoGGJgS2CW70VK5dQM5Oh+7ne47s74VTg==" crossorigin="anonymous"><style>pre {
	padding: .5rem !important;
	line-height: 1 !important;
}
code.fancy-code {
	line-height: 1 !important;
	font-size: 0.75rem !important;
	tab-size: 8 !important;
}
</style><p>(I'll use the abbreviations FP for functional programming and IP for imperative programming.)</p><p>These three are topics that seem to be fundamental in FP (at least from my limited experience in Haskell and Scheme) but somewhat foreign in IP. To me, these three concepts are difficult to understand either in what exactly they are or what they achieve (monads and continuations) or in their implementation (macros<sup id="footnote-1-indicator"><a href="#footnote-1">1</a></sup>).</p><p>There are already plenty of explanations out there on the web, but I wanted to write down the things I found hardest to understand in a simple way.<sup id="footnote-2-indicator"><a href="#footnote-2">2</a></sup></p><p>These explanations were supposed to be short and sweet, but as I was writing more questions and details came up, as they usually do. So I've given each section a tl;dr for those in a hurry.</p><hr><h4>(First-class (reified)) Continuations</h4><h5>tl;dr</h5><p>A continuation (at a given point in the code in the IP, or for an expression in the FP sense) can be thought of as the next instruction the code will take, or the expression in which the current expression's value will be used, along with the context of that "next expression," or "continuation of the expression."</p><h5>Long version</h5><p>The idea is more natural in the FP sense with expressions. Take the following Scheme code as example (from the recent post about streams):</p><pre><code class="fancy-code language-scheme">(define (stream-ref s n)
  ;; get the nth value of a stream
  (if [zero? n]
      (stream-car s)
      (stream-ref (stream-cdr s) (1- n))))
</code></pre><p>Take the expression <code>(stream-car s)</code>. Its continuation is in the <code>if</code> expression, whose continuation is the context of whatever calls the procedure <code>stream-ref</code>. It's easy to say that the continuation of an expression is the expression that calls or uses the value of the expression in question.</p><p>The continuation also includes its <em>context</em> -- all of the lexically scoped values that come along with the current expression. Thus, for the following snippet:</p><pre><code class="fancy-code language-scheme">(let ([x 2] [y 3])
  (* x (1+ (* y 4))))
</code></pre><p>the continuation of the expression <code>(1+ (* y 4))</code> is the multiplication expression <code>(* x ...)</code>, with the value <code>2</code> bound to <code>x</code>.</p><p>Now that we have an intuitive idea of an expression's continuation, now what? Well, we can use it as a control flow structure and jump to some continuation. We need to first get a handle to a continuation we (might) want to use later using the <code>call/cc</code> ("call with current continuation"), and then we can "call" that continuation at a later point, which brings us back to that earlier context. The general form is as so:</p><pre><code class="fancy-code language-scheme">(call/cc
  (lambda (cc)
    ...))
</code></pre><p>where <code>cc</code> is the current continuation (a procedure) of the lambda<sup id="footnote-3-indicator"><a href="#footnote-3">3</a></sup>. If we want to use the continuation, then we call <code>cc</code> with the value we want to send to the current continuation as a value. If we don't call the continuation, then the evaluated value of the lambda will be passed to its continuation as usual. As a very simple example, consider the following nonsensical example (which is basically a nonlocal goto):</p><pre><code class="fancy-code language-scheme">(define (h x cc)
  (if [< x 0] (cc -1) 1))

(define (g x)
  (1+ (call/cc (lambda (cc) (1+ (h x cc))))))

(display (g -1))    ; displays 0, calls cc
(display (g 1))     ; displays 3, doesn't call cc
</code></pre><p>A more illustrative example comes from the Wikipedia page for <code>call/cc</code>:</p><pre><code class="fancy-code language-scheme">(define (f return)
  (return 2)
  3)

(display (f (lambda (x) x)))    ; displays 3, doesn't call cc (return)
(display (call/cc f))           ; displays 2, calls cc (return)
</code></pre><p>This is different than a C/Assembly label (<code>goto</code> label, switch <code>case</code> or <code>default</code> labels, or the implicit labels used by <code>break</code> or <code>continue</code> statements in loops). Those labels are simply branch instructions, and do not capture the context at all, which (among other reasons) makes <code>goto</code> a bad general programming practice. Other issues with gotos are skipped declarations (which is either an error or very dangerous) and the lack of cross-procedure jumps (which can be achieved with <code>setjmp</code>/<code>longjmp</code>, but these also don't capture context and should be handled with care).</p><p>It is more similar to calling a function and returning from that function to the previous function. In this case, we restore the previous context by popping the last stack frame off the stack. In fact, continuations are often used in Scheme to provide non-immediate returns<sup id="footnote-4-indicator"><a href="#footnote-4">4</a></sup>. However, continuations are inherently more powerful than a return point for two reasons: they are "multiply-resumable," which means we can call the continuation multiple times; and they are "optionally-resumable," which means that we don't ever have to call them (similar to the implicit labels in a <code>for</code> loop used for <code>continue</code> and <code>break</code>).</p><p>Because continuations require saving the entire context (call stack), we can think of it as a snapshot of a thread<sup id="footnote-5-indicator"><a href="#footnote-5">5</a></sup>. Because it is multiply-resumable, we must save a copy of the thread -- then this thread representation becomes a <em>reification</em> (concrete implementation) of continuations. Reification is important in order to have first-class continuations as we do in Scheme.</p><p>In IP languages, we don't typically have a reified version of continuations. We can emulate continuations using lambdas by explicitly passing the continuation of an expression to each of its subexpressions -- this is called <em>continuation-passing style</em> (CPS), as opposed to the <em>direct style</em> we are used to. This depends on lambdas capturing their context. Some examples are given in the links below.</p><p>(Another interesting topic that continuations seem to be useful for is <em>coroutines</em>, but I'm not too familiar with them. See the last link. There is also a famous "yin/yang" problem, which is stated on the Wikipedia page.)</p><h5>References</h5><ul><li><a href="https://en.wikipedia.org/wiki/Continuation">Wikipedia: Continuation</a></li><li><a href="https://wiki.c2.com/?ContinuationsAreGotos">c2 wiki: Continuations Are Gotos</a> (the title is misleading, because the article quickly goes into how continuations are not exactly gotos)</li><li><a href="https://wiki.c2.com/?ContinuationExplanation">c2 wiki: Continuation Explanation</a></li><li><a href="https://wiki.haskell.org/Continuation">Haskell wiki: Continuation</a> (Haskell has a monad for continuations, which is linked on the wiki page)</li><li><a href="https://en.wikipedia.org/wiki/Continuation-passing_style">Wikipedia: Continuation-passing style</a></li><li><a href="https://stackoverflow.com/a/612797/2397327">Stack Overflow: What is call/cc?</a> (an example of continuations in Javascript using CPS)</li><li><a href="https://ds26gte.github.io/tyscheme/index-Z-H-15.html">Teach Yourself Scheme in Fixnum Days: Jumps</a> (this has numerous practical examples of <code>call/cc</code>, as well as an explanation of coroutines.).</li></ul><hr><h4>(Structural) Macros</h4><h5>tl;dr</h5><p>Macros are the simplest concept of these three. A macro is a compile-time (preprocessor-time) code rewriting. At the most basic level, as we often see in C/C++, we simply substitute a macro with a constant value. A more complicated version is a macro that takes arguments, which we also see in C/C++. However, while C-style macros give us greater expressive power, they can be dangerous (unhygienic) and only provide basic text-replacement, while macros in Scheme<sup id="footnote-6-indicator"><a href="#footnote-6">6</a></sup></p><h5>Long version</h5><p>A few general notes about macros before we start talking about Scheme's macros:</p><ul><li>Macros don't give us anything new. They just rewrite our source code for us, so that we don't have to write the boring or tricky parts that can be automated. We can do anything we can with macros as we can without macros -- it just would be a pain to do. Think about adding or removing debug code every time you wanted to toggle the debug flag rather than using an <code>ifdef DEBUG</code> macro in C.</li><li>C-style macros are already plenty powerful for most purposes, such as systems programming. A lot of the time all you need is simple toggleable flags or text replacement, and we avoid unhygienic macros by following a naming convention. (But we're not here to talk about what works, we're here to talk about what can be.)</li><li>I used to be confused about when to use (C-style) macros and when to use functions. Macros don't require the overhead of a function call, but they will cause the arguments to be evaluated each time they appear. These make it tricky to choose whether to use a regular procedure or a macro<sup id="footnote-7-indicator"><a href="#footnote-7">7</a></sup>.</li><li>Also marginally related to macros are inline functions in C++, which involve the compiler rewriting code for optimization purposes. We also have compiler optimizations that involve code rewrites, including inlining functions or unwrapping loops. This (optimization) is another possible application of macros, but is usually left to the compiler writer, because there's a good chance they know better than you.</li></ul><p>There are two major problems with C-style macros:</p><ul><li>Our code-rewriting facilities are very weak. Macros use a special preprocessing language that only has a few basic text-replacement commands (e.g., stringifying an argument).</li><li>Rewriting code simply by text manipulation may be dangerous because there is no information about other symbols in the current scope. Declaring a new symbol whose name shadows another symbol in an outside scope in a macro may involve accidental capturing of an external name. This is the hygiene problem<sup id="footnote-8-indicator"><a href="#footnote-8">8</a></sup>.</li></ul><p>TODO: talk about semi-functional languages https://softwareengineering.stackexchange.com/a/253377/378810</p><p>TODO: talk about Rust https://internals.rust-lang.org/t/are-procedural-macros-safe/6399</p><ul><li><a href="https://en.wikibooks.org/wiki/Scheme_Programming/Macros">Wikibooks: Scheme Programming/Macros</a></li><li><a href="https://en.wikipedia.org/wiki/Hygienic_macro">Wikipedia: Hygienic macros</a></li><li><a href="http://community.schemewiki.org/?scheme-faq-macros">scheme-faq-macros</a> (see the section "How are ellipses (...) 'counted' during macro expansion?")</li><li><a href="https://wiki.c2.com/?DefineSyntax">c2 wiki: Define Syntax</a> (the <code>define-syntax</code> special form in Scheme)</li></ul><hr><h4>Monads (and functors, applicatives)</h4><p>TODO: talk about I/O, maybe</p><p>TODO: talk about optional control flow and return values</p><p>TODO: talk about expression containers</p><h5>References:</h5><ul><li><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, and Monads in Pictures</a></li><li><a href="https://wiki.haskell.org/All_About_Monads">Haskell wiki: All about Monads</a></li></ul><hr><h4>Footnotes</h4><p id="footnote-1"><small><a href="#footnote-1-indicator">1.</a> At least the Scheme syntax for it.</small></p><p id="footnote-2"><small><a href="#footnote-2-indicator">2.</a> Another concept I could add to this list is laziness, which has enormous implications but the and motivation for which is intuitive.</small></p><p id="footnote-3"><small><a href="#footnote-3-indicator">3.</a> A regular named procedure taking one argument can be used instead of a lambda, as shown in the next example.</small></p><p id="footnote-4"><small><a href="#footnote-4-indicator">4.</a> Extending off of this idea, we can use continuations to return from nested procedures without having to rewind the whole stack. Similarly, exception handling control flow can be handled this way, also with the potential to cross procedural boundaries. I used this when I wrote a checkers-playing AI, for example, to easily break out of the DFS when the time limit was up.</small></p><p id="footnote-5"><small><a href="#footnote-5-indicator">5.</a> The various wiki pages below note that continuations and threads are roughly equivalent in power, in that they can be used to implement one another. It is left as an exercise to the reader to implement continuations in C using <code>fork()</code>.</small></p><p id="footnote-6"><small><a href="#footnote-6-indicator">6.</a> And presumably other FP languages. Template Haskell is an extension for Haskell that allows macros, but I'm not aware of many other FP languages' macro support.</small></p><p id="footnote-7"><small><a href="#footnote-7-indicator">7.</a> For example, the <a href="https://dustri.org/b/min-and-max-macro-considered-harmful.html">common MIN and MAX macros</a>.</small></p><p id="footnote-8"><small><a href="#footnote-8-indicator">8.</a> The reason it is called hygienic, from <a href="https://wiki.c2.com/?DefineSyntax">c2 wiki: Define Syntax</a>: "Hygienic means clean or sanitary. Something is hygienic if it does not contaminate unrelated things. For example, surgical practices are hygienic if they do not leave blood and guts lying around to contaminate a wound. Scheme macros are hygienic if they do not affect code outside of their proper scope."</small></p><hr><p>&copy; Copyright 2021 Jonathan Lam</p></body></html>