<!DOCTYPE html><html><head><title>jlam | SICP notes: functional programming</title><style>html {
	box-sizing: border-box;
	margin: 0;
	padding: 0.5rem;
}
body {
	max-width: 400pt;
	margin: 0 auto;
	padding: 0;
}</style><link rel="icon" href="/res/favicon.png"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><h1>Jonathan Lam</h1><p>EE/CS @ The Cooper Union</p><nav><a href="/">Home</a> | <a href="/contact">Contact</a> | <a href="/experience">Experience</a> | <a href="/res/resume.pdf" target="_blank">Resume</a> | <a href="http://files.lambdalambda.ninja">Files</a> | <a href="/blog">Blog</a></nav><hr><!-- inspiration taken from https://codepen.io/Zoxon/pen/WyqdBb--><!-- styles for blog posts--><style>kbd {
	background-color: #eee;
	padding: 0 3px;
	border: 1px solid black;
	border-radius: 2px;
}
blockquote {
	margin: 0;
	background-color: #eee;
	padding: 1px 1em;
}
li {
	margin-block-start: 1em;
	margin-block-end: 1em;
}
</style><h2>Blog</h2><h3>SICP notes: functional programming</h3><p>On 7/6/2021, 9:46:07 PM</p><p><a href="/blog">Return to blog</a></p><hr><p>This post is about Chapter 3.1-3 of <em>SICP</em>. Ironically (in a post about the meaning of functional programming), these sections are about mutation and state, which are more commonly associated with non-functional paradigms.</p><p>The purpose of this post is to describe what functional programming is. In the small group discussions we hold for this independent study, Prof. S<sup id="footnote-1-indicator"><a href="#footnote-1">1</a></sup> and I both had some revelations about what it means according to Abelson and Sussman, as opposed to what we had originally thought.</p><p>Prof. S had worked with Scheme in the past, and his impression was that functional programming primarily dealt with (linked-)list processing -- as opposed to dealing with more concrete data structures like structs and arrays.<sup id="footnote-2-indicator"><a href="#footnote-2">2</a></sup></p><p>My previous intuition was that functional programming was all about dealing with functions as first-class objects, like lambda calculus. This means a lot of clean code and aggregate operations like <code>filter</code>, <code>map</code>, and <code>reduce</code> (or <code>fold-left</code>/<code>fold-right</code>).</p><p>As we went through the first two chapters<sup id="footnote-3-indicator"><a href="#footnote-3">3</a></sup>, we were always pulling parallels to grogramming constructs that we see in other languages, especially object-oriented languages. This is almost definitely because we are most familiar with these languages, like C++ and Java. By the end of Chapter 2, we see things that look quite a bit like objects: we design primitive "type systems" and consider inheritance patterns, and we see object-like structures: functions that bind state to a variable. These objects have "constructors" and "selectors" ("getters"). There are no "mutators" ("setters") mentioned before Chapter 3, but that is okay -- we can simply construct a new "object" if we want to change the value of a "field," and all is well.</p><p>At multiple times throughout the independent study thus far, Prof. S has said something along the lines of: "I see how [templates/polymorphism/lambdas] is powerful, but I still feel like it's a lot easier to do this using [C++/Java]." And I agree, but I also think that it's not the point of this book -- rather, <em>SICP</em> is about considering the design of programs and the design of programming languages, in order to become a better programmer. I think the question keeps coming up because the stark minimialism of Scheme still hasn't registered as "normal" with Prof. S, and thus we want to relate to concepts in more familiar languages.</p><p>But up to Chapter 3, the comparisons we made were implicitly between a functional programming language and an imperative or object-oriented one. The authors are cunning and deliberate<sup id="footnote-4-indicator"><a href="#footnote-4">4</a></sup>: they sneak in important concepts by means of example and connect names to those concepts only after the examples have practically spoken for themselves.<sup id="footnote-5-indicator"><a href="#footnote-5">5</a></sup> Most noticeably, the "object" still felt very different from the standard idea of objects in OOP languages, perhaps because of the lack of mutators, and we don't have advanced data structures such as hashtables that require mutation of memory cells<sup id="footnote-6-indicator"><a href="#footnote-6">6</a></sup>. Actually, we haven't memory cells at all -- maybe only some hand-wavy mentions of "pointers." What gives?</p><p>The missing piece is found in Chapter 3. Suddenly, we are handed the <code>set!</code> function (and the similar <code>set-car!</code> and <code>set-cdr!</code>). The first or second concept we learn in a conventional programming class are variables. We learn how to set a variable to one variable, and then change its value to another. We learn that <code>x = x+1</code> is not an equation but rather than an assignment (or we learn the walrus operator, which has the same effect), and we accept it immediately. It makes sense, right? <code>x</code> stores a value, and maybe that value can change over time as we mutate it.</p><p>(At this point, we should be very clear what we mean by assignment versus mutation. Assignment means the binding of a value to a variable, whereas mutation means changing the value that a variable is bound to. In Scheme, we can think of every variable as a pointer to some memory location. Assignment or reassignment means setting the pointer to point to some value in memory, and this is what <code>define</code> or <code>let</code> do. Mutation means to change the value in the memory cell that the variable is pointing to (via a pointer dereference), and this is what <code>set!</code> does.)</p><p>Without assignment, we've been able to survive two interesting chapters which build increasingly complex abstractions. We are given the <code>define</code> and <code>let</code> operators, but these only allow you to bind a name once in a scope<sup id="footnote-7-indicator"><a href="#footnote-7">7</a></sup>. It's as if we lived in the world of ANSI C89, where declarations are either top-level declarations or must be located at the top of a scope, and all variables were declared <code>const</code><sup id="footnote-8-indicator"><a href="#footnote-8">8</a></sup>. And so far, the only composite data structures we've worked with are the lambda (whose closure can store values) and <code>cons</code>, as if we had a generic <code>Pair<?, ?></code> type in Java as the only basic type. With these two basic building blocks, we've been able to write binary search trees, an N-queens solver, paintings, a type system, and pseudo-objects. Everything that can be achieved with mutation can be achieved with immutable bindings<sup id="footnote-9-indicator"><a href="#footnote-9">9</a></sup> <sup id="footnote-10-indicator"><a href="#footnote-10">10</a></sup> <sup id="footnote-11-indicator"><a href="#footnote-11">11</a></sup>.</p><p>Despite the fact that we still <em>can</em> achieve the same things without mutation, mutation <em>feels</em> very useful. With mutation we can be satisfied with making a "true" object, where we change the values of variables by mutating their memory cells, as the authors show in the example about a bank account. We can now have a closed form for a PRNG, which is somewhat impossible in a purely functional form, because we have to store the previous state.<sup id="footnote-12-indicator"><a href="#footnote-12">12</a></sup> As I've mentioned in the footnotes multiple times by now, we also get all the array-based data structures, which are extremely useful because of the way RAM is linear and constant-time random-access.</p><p>We've just described what we gain -- and this is intuitive, because we already deal with mutation all the time and see that it is a very practical concept. But what do we lose? What happens if we don't allow mutation, if we only allow for immutable bindings?<sup id="footnote-13-indicator"><a href="#footnote-13">13</a></sup> The concrete examples of why immutability is helpful are the following:</p><ul><li><strong>The substitution model</strong> The basis of any program is computing expressions. In Scheme, expressions are function applications. To evaluate an expression, we must first evaluate all of its arguments by substitution. This process happens naturally and makes it easy for us to manually trace program flow, but it is broken by assignment. With mutation, a variable may refer to multiple values at different times, which forces us to use the more complicated "environment model" that is proposed in sections 3.2-3.</li><li><strong>Referential transparency</strong><sup id="footnote-14-indicator"><a href="#footnote-14">14</a></sup> In a referentially transparent program or programming language, variables are synonymous with their values. Checking equality of two values is the same as checking the equality of two variables (i.e., their references). The most obvious version of this are quoted symbols in Scheme (e.g., <code>'apple</code> or <code>'()</code>). These symbols can be thought of as variables or values.</li><li><strong>Structural sharing</strong> If a value needs to be shared by multiple objects, then all those objects can share the same value. This is seen in many popular languages in which string literals are immutable (e.g., C, Java): if the same string literal appear multiple times in a program, they all refer to the same place in memory. This goes hand-in-hand with referential transparency, and has huge implications in performance and memory consumption (see below note about Redux).</li><li><strong>History of states</strong> See below note about Redux.</li><li><strong>Race conditions</strong> Race conditions are by definition when there are multiple concurrent I/O operations to a mutable memory location. By avoiding mutation when possible, we can attempt to avoid race conditions. Of course, this is not always possible, such as in highly parallelized DBMSes. But immutability is useful parallel programming (e.g., parallel streams) by eliminating locking.</li></ul><p>A famous example of points 2, 3, and 4 is the Redux Javascript library, a state management library, and other immutable-object libraries like Immutable.JS. For the unfamiliar, you can think of Redux as a lightweight database for your web application. Referential transparency implies that you can check that an object has changed simply by checking if it has been reassigned -- no deep check is needed except for objects that have been reassigned (a huge performance boost). Structural sharing means a value that is a member of multiple objects only appears once in memory (a huge memory saver). Another benefit of the memory savings is that we can efficiently store a history of the (immutable) states as an array or stream, which allows us to "replay history" -- which is both useful in debugging and very cool! While this means we have to store each new value in each state somewhere in memory, reused values (which likely form the majority of the Redux state) don't get duplicated.</p><p>These practical points above are specific examples of general considerations that I understand to be the design principles of immutable design:</p><ul><li><strong>The idea of "sameness" (and time)</strong> With referential transparency, we are able to say that two variables are the same iff. their values are the same. Practically, this manifests when we have two variables pointing to the same immutable object, and we can say that reference equality is the same as value equality. (In Java, for example, this would look like: <code>==</code> would mean the same as <code>.equals()</code>). This makes it easier to reason about our code. A value (a memory cell) has no concept of time: it always holds the same value when someone accesses it. This also has to do with eliminating race conditions. When we encounter streams in section 3.5, we show that we can emulate "time" by having a history of immutable states, and can act on this like a sequence.</li><li><strong>Predictability</strong> A value doesn't change over the course of a program. A variable is only bound once. We can predict the behavior of programs more easily with the simple substitution model, and we get rid of undefined behavior scenarios due to possible mutation of variables (e.g., avoid the UB situations in C when using multiple post-increment operators in the same expression, or caring about the order of evaluation of function parameters).</li><li><strong>Performance and efficiency</strong> Increased performance is due to the practical considerations above, such as in the Redux library<sup id="footnote-15-indicator"><a href="#footnote-15">15</a></sup>. Increased programmer efficency is due to the higher predictability of code, and may greatly outweigh the small performance hit, if any.</li><li><strong>Expression-based (as opposed to statement-based)</strong> We are more focused with dealing with calculating values and expressions rather than a sequence of operations. (A sequence acts like change over "time.")</li></ul><p>Okay, I've talked long enough about immutability, but what does this have to do with functional programming? And it turns out that this <em>is</em> functional programming. Abelson and Sussman provide us the following definition of FP:</p><blockquote><p>Programming without any use of assignments, as we did throughout the first two chapters of this book, is accordingly known as <em>functional programming</em>.</p></blockquote><p>TODO: Which one is more intuitive?</p><p>TODO: bring it back to the beginning</p><hr><h4>Footnotes</h4><p id="footnote-1"><small><a href="#footnote-1-indicator">1.</a> This is the convention I used in my previous blog when referring to real people, and I will stick to it.</small></p><p id="footnote-2"><small><a href="#footnote-2-indicator">2.</a> Somewhat related: When I proposed this independent study, his understanding was that this book uses Lisp because it teaches functional programming, and suggested that we use a more modern functional language like Python or Haskell. My understanding was that this book was not about functional programming at all, but rather that it chooses Lisp as a lens for studying program design for its minimalism and metaprogramming capabilities, and it happens to be a mostly-functional language. It took a while to convince him that the independent study was not about Lisp or functional programming, but about the <em>shape</em> of programs.</small></p><p id="footnote-3"><small><a href="#footnote-3-indicator">3.</a> Chapter 1 deals with procedural abstractions, and Chapter 2 with data abstractions.</small></p><p id="footnote-4"><small><a href="#footnote-4-indicator">4.</a> <em>Scheme</em>rs, if you will.</small></p><p id="footnote-5"><small><a href="#footnote-5-indicator">5.</a> While this is perhaps the best part about SICP, this is also one of my criticisms -- for the unaware reader, it may seem like the book is throwing you examples before you're ready to deal with them. Sometimes the tools needed are not given to you! The authors sometimes don't give implementations of crucial functions, such as <code>put</code> and <code>get</code> in 2.4 (these require material from Chapter 3), some of the concurrency primitives in 3.4 (this involves non-standard Scheme to support asm instructions), and <code>make-delay</code> in 3.5 (this requires macros). This is great for the inquisitive reader with some background in programming, but it requires a decent amount of prior knowledge. I believe this is the most common criticism of the book.</small></p><p id="footnote-6"><small><a href="#footnote-6-indicator">6.</a> This is a common criticism of functional languages. See <a href="https://jaxenter.com/disadvantages-of-purely-functional-programming-126776.html">this</a>.</small></p><p id="footnote-7"><small><a href="#footnote-7-indicator">7.</a> In a REPL or a non-standard program, <code>define</code> may allow redefinitions in the same scope. But in a standards-compliant program, that's not allowed.</small></p><p id="footnote-8"><small><a href="#footnote-8-indicator">8.</a> It would be very interesting and probably very ugly to code like this in C.</small></p><p id="footnote-9"><small><a href="#footnote-9-indicator">9.</a> If you allow enough nested scopes.</small></p><p id="footnote-10"><small><a href="#footnote-10-indicator">10.</a> This is a laymen's way of saying that lambda calculus and Turing machines are equivalent models of computation.</small></p><p id="footnote-11"><small><a href="#footnote-11-indicator">11.</a> Efficiency may not be equivalent without mutation for certain data structures and algorithms, such as in arrays and array-based structures (e.g., heaps, hashtables) or the Sieve of Eratosthenes. See the earlier footnote. But we can still emulate them in functional programming. The authors are very deliberate not to mention hashtables at all (at least up to Chapter 4). They mention the Sieve of Eratosthenes in 3.5 when mentioning streams, which is still a functional programming concept, but their implementation is very inefficient. I'll mention this in a later post about <SICP></SICP>'s discussion of streams.</small></p><p id="footnote-12"><small><a href="#footnote-12-indicator">12.</a> Actually, we can achieve this using streams (section 3.5), which actually stores the entire history of a variable's state. In other words, the stream is an infinite list of immutable states. More to come in a future post about streams.</small></p><p id="footnote-13"><small><a href="#footnote-13-indicator">13.</a> This is supposed to be the climax of the post, but I can't think of a climactic way to display everything, so it's gonna go in a boring list. These are my key takeaways from these sections and are, in general, what I believe to be the strengths of immutability and functional programming, but it is of course not exhaustive.</small></p><p id="footnote-14"><small><a href="#footnote-14-indicator">14.</a> There is a more precise definition of referential transparency than what I present here, which is just for the general idea.</small></p><p id="footnote-15"><small><a href="#footnote-15-indicator">15.</a> However, there are also performance tradeoffs as mentioned many times before, but <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-20.html#call_footnote_Temp_339"><em>SICP</em> suggests that the widespread belief is more pessimistic about functional programming performance than the reality</a>. Some Scheme flavors and other functional languages like OCaml or Haskell can achieve very close to C speeds.</small></p><hr><p>&copy; Copyright 2021 Jonathan Lam</p></body></html>