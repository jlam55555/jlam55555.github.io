<!DOCTYPE html><html><head><title>jlam | Falling in love with Haskell</title><style>html {
  box-sizing: border-box;
  margin: 0;
  padding: 0.5rem;
}
body {
  max-width: 400pt;
  margin: 0 auto;
  padding: 0;
}</style><link rel="icon" href="/res/favicon.png"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><h1>Jonathan Lam</h1><p>Core Developer @ Hudson River Trading</p><nav><a href="/">Home</a> | <a href="/contact">Contact</a> | <a href="/experience">Experience</a> | <a href="//github.com/jlam55555/resume/raw/master/resume.pdf" target="_blank">Resume</a> | <a href="/blog">Blog</a></nav><hr><!-- inspiration taken from https://codepen.io/Zoxon/pen/WyqdBb--><!-- styles for blog posts--><style>kbd {
	background-color: #eee;
	padding: 0 3px;
	border: 1px solid black;
	border-radius: 2px;
}
blockquote {
	margin: 0;
	background-color: #eee;
	padding: 1px 1em;
}
li {
	margin-block-start: 1em;
	margin-block-end: 1em;
}
h5 {
	font-size: 1em;
	color: #666;
	margin-bottom: 1em;
}
</style><h2>Blog</h2><h3>Falling in love with Haskell</h3><p>On 7/22/2021, 10:00:55 PM</p><p><a href="/blog">Return to blog</a></p><hr><p><strong>Update 12/20/21</strong>: I'm only getting around to filling this placeholder post now. When I set out to write this post in July, I was in the middle of an independent study using Lisp and had just begun tutorials on Haskell, that being the first of the Miranda- or ML-family languages that I'd played around with. By this point, I've had a lot of time to play around more with Haskell and other functional languages (OCaml, Rust, Agda, and Hazel). Luckily, I left some annotations here earlier, so I hope I can remain somewhat true to the "first impressions" by going off of those. Whatever the case, no post will be able to capture the immensity of the reaction when trying to understand Haskell for the first time. Some of these confusions I still hold now, a few months and one Haskell project later.</p><p>Haskell is a culture shock. I'm mostly familiar with three families of languages: the C-like, statically-typed languages; the high-level, dynamically-typed, partially-functional languages like Python; and the dynamically-typed free-for-all that is Lisp. But a statically-typed purely-functional language? It feels wrong from the standpoint of the "static imperative, dynamic functional" mantra.</p><p>Also, why is Haskell so hard? <em>A gentle introduction to Haskell</em>, which I used to learn Haskell, was anything but gentle<sup id="footnote-1-indicator"><a href="#footnote-1">1</a></sup>. This is the densest tutorial material I have ever read. I thought it is easy for me to learn any (non-esoteric, or at least somewhat-mainstream) programming language, but I was wrong.</p><p>The idea of a constructor is fascinating. It is really a declaration, rather than the typical OOP constructor which can set up state. Variant types are like unions, but safer and potentially carrying no data (like an enum).</p><p>The type system seems very powerful (or at least, that's what everyone seems to be saying), but I don't understand all of it. What is the Hindley-Milner type system? The difference between type- and data-constructors took me a long time to understand<sup id="footnote-2-indicator"><a href="#footnote-2">2</a></sup>. What is the difference between <code>type</code>, <code>newtype</code>, and <code>data</code>? Types being parameterized on other types feels like polymorphism, but I'm not sure if it's just parametric polymorphism or something more powerful. Type constraints mostly seem to make sense. I don't understand universal or existential quantification in the context of types. I don't quite understand the idea of type classes -- does this correspond to any concepts in OOP, and if so, what? Actually, what parts of the Haskell type system can be explained in types of OOP? It's cool that pattern matching can not only match variables, but constants as well.</p><p>The idea of an exception type <em>bottom</em> is confusing.</p><p>The simple quicksort that's always being thrown around as an example is beautiful. As is the examples of streams using laziness. Actually, most of the stuff using laziness is pretty beautiful. I wonder what the performance cost of laziness is. The idea of currying is also mathematically beautiful.</p><p>Talking about beautiful, monads are questionably beautifuly. They feel like a large intellectual effort to do things in a purely functional way that could be done trivially in an imperative context. The ones that I know at the moment are the <code>IO</code>, <code>Maybe</code>, <code>ST</code>, and <code>List</code> monads. Applicatives and functors are also cool. I don't totally understand applicatives, but functors I can easily grok through the idea of the <code>map</code> function. Lifting an operator also is intuitive.</p><p>Haskell has a nice documentation (Hoogle), and ghci seems to have a lot of modern features<sup id="footnote-3-indicator"><a href="#footnote-3">3</a></sup>.</p><p>The syntax is pretty difficult and rigid. Like Python, indentation is important (too important?), although it is more flexible with exactly how much you indent as long as it's more than the previous line. Builtin names of operators, especially those for builtin algebraic classes like monads, are not intuitive at all. Record syntax is a little annoying or at least weird.</p><p>The community is difficult to understand -- it feels like everyone is an academic studying programming languages. The barrier of entry seems high unless you have someone to guide you through the process.</p><hr><h4>Footnotes</h4><p id="footnote-1"><small><a href="#footnote-1-indicator">1.</a> I want to read <em>Learn you a Haskell for great good</em>, but only once I have some time.</small></p><p id="footnote-2"><small><a href="#footnote-2-indicator">2.</a> Although I believe this to be mostly due to <em>A gentle introduction to Haskell</em> never explaining it explicitly.</small></p><p id="footnote-3"><small><a href="#footnote-3-indicator">3.</a> I only learned about the cabal/stack package managers and the Hackage/Stackage repositories later when working on a Haskell project, and they are also pretty good.</small></p><hr><p>&copy; Copyright 2023 Jonathan Lam</p></body></html>