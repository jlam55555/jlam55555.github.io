<!DOCTYPE html><html><head><title>jlam | Understanding the tty subsystem: Line discipline</title><style>html {
  box-sizing: border-box;
  margin: 0;
  padding: 0.5rem;
}
body {
  max-width: 400pt;
  margin: 0 auto;
  padding: 0;
}</style><link rel="icon" href="/res/favicon.png"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><h1>Jonathan Lam</h1><p>Core Developer @ Hudson River Trading</p><nav><a href="/">Home</a> | <a href="/contact">Contact</a> | <a href="/experience">Experience</a> | <a href="//github.com/jlam55555/resume/raw/master/resume.pdf" target="_blank">Resume</a> | <a href="/blog">Blog</a></nav><hr><!-- inspiration taken from https://codepen.io/Zoxon/pen/WyqdBb--><!-- styles for blog posts--><style>kbd {
	background-color: #eee;
	padding: 0 3px;
	border: 1px solid black;
	border-radius: 2px;
}
blockquote {
	margin: 0;
	background-color: #eee;
	padding: 1px 1em;
}
li {
	margin-block-start: 1em;
	margin-block-end: 1em;
}
h5 {
	font-size: 1em;
	color: #666;
	margin-bottom: 1em;
}
</style><h2>Blog</h2><h3>Understanding the tty subsystem: Line discipline</h3><p>On 5/4/2023, 5:47:27 PM</p><p><a href="/blog">Return to blog</a></p><hr><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-zc7WDnCM3aom2EziyDIRAtQg1mVXLdILE09Bo+aE1xk0AM2c2cVLfSW9NrxE5tKTX44WBY0Z2HClZ05ur9vB6A==" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" integrity="sha512-vswe+cgvic/XBoF1OcM/TeJ2FW0OofqAVdCZiEYkd6dwGXthvkSFWOoGGJgS2CW70VK5dQM5Oh+7ne47s74VTg==" crossorigin="anonymous"><style>pre {
	padding: .5rem !important;
	line-height: 1 !important;
}
code.fancy-code {
	line-height: 1 !important;
	font-size: 0.75rem !important;
	tab-size: 8 !important;
}
</style><p>This is the second part of a two-part series describing the tty subsystem. See the first part describing the subsystem and giving an overview of its architecture <a href="/blog/54">here</a>.</p><p>Initially, I had thought that these "extra terminal behaviors" were unnecessary and not critical to my understanding and implementation of the terminal in Linux. I was very wrong; not only does line discipline make up many useful and familiar behaviors that create the look and feel of a terminal, but keeping it separate from the tty driver helps preserve the distinction between policy and mechanism in the kernel.</p><hr><h4>Overview of the line discipline</h4><p>While tty devices are mostly a "dumb" device, acting as a bidirectional channel between keyboard/console (master) and process (slave), there are a number of useful special semantics that have evolved over the years that suit the asymmetric, interactive terminal interface. Some well-known examples include:</p><ul><li>Typed characters (input) show up on the console (output) by default even without any process printing this out. This is called <em>echoing</em>.</li><li>Backspacing in the input allows you to perform basic line editing. This type of line-based editing is called <em>cooked mode</em> or <em>canonical mode</em>. (We call it <em>raw mode</em> when cooked mode is disabled.)</li><li>Pressing the special interrupt control character, usually <kbd>Ctrl</kbd>+<kbd>C</kbd> (alternatively notated <kbd>^C</kbd>), sends a signal to the slave process.</li></ul><p>Overall, this behavior is called the <em>line discipline</em>, and it describes the behavior ("policy") of the terminal device. Recall from the <a href="/blog/54">earlier blog post</a> that the other major component of the tty/terminal subsystem is the terminal driver, which provides an interface to the input and output serial hardware devices ("mechanism"). All operations on a terminal device go through the line discipline interface.</p><h5>Line discipline interface</h5><p>The line discipline interface comprises three functions for normal operation:</p><ul><li><code>receive_buf()</code>: called by the terminal driver to send input to the line discipline</li><li><code>read()</code>: called by the slave to read from the line discipline (input) buffer</li><li><code>write()</code>: called by the slave to write to the output buffer; should forward writes to the terminal driver</li></ul><p>Additionally, the line discipline should be able to receive <code>ioctl</code>s to change its behavior, i.e., through the <code>termios</code> interface described below. This interface is defined in <code>struct tty_ldisc_ops</code> defined in <code>include/linux/tty_ldisc.h</code>.</p><p>The interactions between the line discipline and the tty driver are summarized in the following diagram.</p><pre><code class="fancy-code language-text">+-----------------+
| process         |
+-----------------+
        |  |
write() |  | read()
        v  v
+-----------------+
| ldisc           |
+-----------------+
        |  ^
write() |  | receive_buf()
        v  |
+-----------------+
| tty driver      |
+-----------------+
        ^    |
        |    |
        |    v
+--------+  +--------+
| input  |  | output |
| serial |  | serial |
| device |  | device |
+--------+  +--------+</code></pre><hr><h4>Special characters</h4><p>Before going into specifics about line discipline behavior, we should review special ASCII characters, notation, and common keys.</p><p>In ASCII, there are 128 characters. Characters 0-31 are special, non-printable characters. Characters 32-127 are printable characters. Any character with the parity bit set (characters 128-255) are not valid ASCII and may be handled normally or filtered out using terminal settings (e.g., <code>ignpar</code>, <code>inpck</code>).</p><p>In this section we focus on the low 32 characters. Each of these characters can be entered with a control sequence; for example, ASCII 0x01 can be entered using <kbd>Ctrl</kbd>+<kbd>A</kbd>; we denote this using Emacs notation as <kbd>^A</kbd>. Some keys on the keyboard are mapped to special keys, such as <kbd>Enter</kbd> being mapped to <kbd>^M</kbd>. Important special characters are summarized in the below table; a more comprehensive table can be found <a href="https://www.cisco.com/c/en/us/td/docs/ios/12_4/cfg_fund/command/reference/cfnapph.html">here</a>.</p><table><thead><tr><th>ASCII</th><th>Name</th><th>Key</th></tr></thead><tbody><tr><td>0x00</td><td>null</td><td><kbd>^@</kbd></td></tr><tr><td>0x03</td><td>break/interrupt</td><td><kbd>^C</kbd></td></tr><tr><td>0x08</td><td>backspace</td><td><kbd>^H</kbd></td></tr><tr><td>0x0A</td><td>line feed (LF)</td><td><kbd>^J</kbd></td></tr><tr><td>0x0D</td><td>carriage return (CR)</td><td><kbd>^M</kbd> or <kbd>Enter</kbd></td></tr><tr><td>0x1B</td><td>escape</td><td><kbd>^[</kbd> or <kbd>Esc</kbd></td></tr><tr><td>0x7F</td><td>delete</td><td><kbd>^?</kbd> or <kbd>Bksp</kbd></td></tr></tbody></table><p>The <kbd>^H</kbd>, <kbd>^J</kbd>, and <kbd>^M</kbd> characters are understood by a terminal console driver; they are commands to move the cursor left, down, and to the beginning of a line, respectively. The <kbd>^J</kbd> character signals the end of a line in canonical mode. The <kbd>^?</kbd> character is used to delete backwards in canonical mode. The <kbd>^C</kbd> character is used to send the SIGTERM signal when <code>isig</code> is enabled.</p><p>There may be some confusion around the <kbd>Enter</kbd> (which produces a carriage return rather than a newline character) and <kbd>Bksp</kbd> (which produces a delete key rather than a backspace key). I believe it is mostly historical significance but am not too sure. The mixup between <kbd>^M</kbd> (produced by <kbd>Enter</kbd>) and <kbd>^J</kbd> (universally understood by Linux to mean end-of-line) is common enough that a common terminal setting exists to convert <kbd>^M</kbd> to <kbd>^J</kbd> called <code>icrnl</code>.</p><hr><h4>Canonical mode</h4><p>In <a href="https://www.gnu.org/software/libc/manual/html_node/Canonical-or-Not.html">canonical mode</a> (a.k.a., cooked mode), special characters may be used to provide editing within a line. Usually these are the <em>erase</em> (default <kbd>^?</kbd> or <kbd>Bksp</kbd>) and <em>kill</em> (default <kbd>^U</kbd>) keys, which erase the last character and the whole line, respectively.</p><p>Since you can edit a line, a read operation on a terminal in canonical mode will not complete until the end of line is reached (<kbd>^J</kbd> is sent). Similarly, no more than one line will be sent for any read command, no matter how many bytes are requested.</p><p>The opposite of cooked mode is called raw mode. In raw mode, reads return as soon as there is data (possibly throttled for performance), and the erase and kill characters have no special meaning.</p><h5>Quirks of canonical-mode line-based editing</h5><p>The line discipline uses a 4KB ringbuffer (by default) to manage data. In canonical mode, data is not sent to the application until a line feed (<kbd>^J</kbd>) character is written to the input buffer.</p><p>One aspect of this behavior is that when a program reads input from a cooked-mode terminal, the read call doesn't finish until the LF character is sent. A call to <code>getchar()</code> in libc would not instantly return once a character is inputted, unless the character was a line feed; instead, it would read the entire line and return the first byte of the terminal buffer.</p><p>Having a fixed-size line editing buffer also means that extra characters are discarded once the buffer is exhausted. If the input buffer is full, future characters are still processed (signals, echoing, etc.) but new characters will be lost. <a href="https://man7.org/linux/man-pages/man3/termios.3.html"><code>termios(3)</code></a> documents this behavior. We can observe this by entering more than 4096 characters of input<sup id="footnote-1-indicator"><a href="#footnote-1">1</a></sup> for a program reading from stdin in cooked mode, and checking how many characters are actually received.</p><p>Note that this buffer overflow can also happen in raw mode if the buffer is not emptied quickly enough.</p><hr><h4>Echo functionality</h4><p>Usually, when interacting with a terminal, we are able to see each character that we type. This is called echoing; it works by "echoing" (copying) each byte from the input buffer to the output buffer, so that it gets displayed.</p><p>When we type characters into the terminal with echoing enabled, the characters are normally also written onto the output buffer and displayed onto the console. For printable characters, this does exactly what we expect. What happens for non-printable (control characters)?</p><p>Control characters will be printed out in Emacs notation (e.g., "^@" for <kbd>Ctrl</kbd>+<kbd>2</kbd>). The special characters are escaped before being echoed to the output buffer. The slave side receives the unescaped characters, and any special characters written to output buffer are not escaped automatically.</p><p>Some control keys will be handled specially in cooked mode and thus not be printed, such as <kbd>^?</kbd>.</p><p>Echoing can also be disabled (e.g., when entering passwords) using the <code>termios</code> interface.</p><hr><h4>Configuring terminal devices in Linux</h4><p>Terminal devices in Linux can be configured using the <code>termios</code> C interface. This interface exposes the <code>tcgetattr()</code>/<code>tcsetattr()</code> functions to fetch and set the terminal configuration via <code>ioctl()</code>s, respectively. The terminal configuration exists as a set of flags that define the terminal behavior; some sample flags from the <code>termios</code> interface are shown below:</p><ul><li><strong>INPCK</strong>: Disable parity check for input characters (allows non-ASCII characters).</li><li><strong>ICRNL</strong>: Convert carriage return (CR) characters to line feed (line feed) characters. This is commonly enabled since the <kbd>Enter</kbd>/<kbd>Return</kbd> key is ommonly mapped to CR, but the terminal uses LF characters to represent the mark the end of a line.</li><li><strong>ICANON</strong>: Enable canonical mode.</li><li><strong>ECHO</strong>: Enable echoing.</li></ul><p>While the termios interface may be useful when writing a C program that manages terminal properties (e.g., if you are a program like <code>bash</code>), then using the C interface directly is fine. However, the <code>stty</code> interface is a useful shell utility to change terminal properties on command. For example, we can enable echoing using <code>stty echo</code>, disable echoing using <code>stty -echo</code>, enable raw mode using <code>stty raw</code>, and enable cooked mode using <code>stty cooked</code>. There are many more options available to match much of the <code>termios</code> interface; see the manpages for <a href="https://man7.org/linux/man-pages/man3/termios.3.html"><code>termios(3)</code></a> and <a href="https://man7.org/linux/man-pages/man1/stty.1.html"><code>stty(1)</code></a>.</p><hr><h4>Experiment with <code>sh</code> rather than <code>bash</code></h4><p>If you try and experiment with terminal features on your own using the <code>stty</code> shell command, you may have unexpected results if using the <code>bash</code> shell. At least, it will be unexpected if you don't understand what <code>bash</code> does under-the-hood (as I didn't); most of the time, the good ol' Bourne shell <code>sh</code> will give the expected result.</p><p>To give a simple illustration, try entering the following experiments in <code>bash</code> and <code>sh</code>. The following experiments are all done in raw mode, by first entering <code>stty raw</code> <kbd>Enter</kbd> into the shell<sup id="footnote-2-indicator"><a href="#footnote-2">2</a></sup> <sup id="footnote-3-indicator"><a href="#footnote-3">3</a></sup>.</p><ol><li><kbd>^C</kbd> <code>whoami</code> <kbd>Enter</kbd></li><li>abc <kbd>Bksp</kbd></li><li><code>cat -A</code> <kbd>Enter</kbd> <kbd>^C</kbd> <code>abc</code> <kbd>Bksp</kbd></li><li><code>cat -A</code> <kbd>^J</kbd> <kbd>^C</kbd> <code>abc</code> <kbd>Bksp</kbd></li></ol><p>Here are my results:</p><ol><li><code>bash</code>:<pre><code class="fancy-code language-text">$ ^C
$ whoami
jon
   $</code></pre><code>sh</code>:<pre><code class="fancy-code language-text">$ ^Cwhoami^M</code></pre></li><li><code>bash</code>:<pre><code class="fancy-code language-text">$ ab</code></pre><code>sh</code>:<pre><code class="fancy-code language-text">$ abc^?</code></pre></li><li><code>bash</code>:<pre><code class="fancy-code language-text">$ cat -A
^C^Caabbcc^?^?</code></pre><code>sh</code>:<pre><code class="fancy-code language-text">$ cat -A^M^Cabc^?</code></pre></li><li><code>bash</code>:<pre><code class="fancy-code language-text">$ cat -A
^C^Caabbcc^?^?</code></pre><code>sh</code>:<pre><code class="fancy-code language-text">$ cat -A^J^C^Caabbcc^?^?</code></pre></li></ol><p>Phew! There's a lot of nuance here. Before going through each example, it'll be easier if I provide the overall reason for the differences upfront: <code>bash</code> changes the terminal settings when prompting the user for a command. That is, it provides nice line-editing features via user-level software, and not via the terminal itself. However, before <code>exec</code>-ing a program (e.g., <code>cat</code>, it restores the terminal settings. <code>sh</code> doesn't provide any custom line editing semantics in the prompt, so we see the truer terminal behavior. To summarize, <code>bash</code> overrides the terminal settings in the command prompt, while <code>sh</code> doesn't<sup id="footnote-4-indicator"><a href="#footnote-4">4</a></sup>; however, both share the same behavior within a program executed by the shell.</p><p>Another thing we need to look into is exactly what <code>stty raw</code> does, since it turns a number of terminal flags. Looking at the manpage for <a href="https://man7.org/linux/man-pages/man1/stty.1.html"><code>stty(1)</code></a>, we see that the <code>raw</code> option is shorthand for:</p><pre><code class="fancy-code language-text">-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr -icrnl -ixon -ixoff -icanon -opost -isig -iuclc -ixany -imaxbel -xcase min 1 time 0</code></pre><p>That's a handful, but the main options we care about are:</p><ul><li><strong>-icanon</strong>: Turn off canonical line editing.</li><li><strong>-isig</strong>: Turn off signal processing (e.g., don't handle <kbd>^C</kbd>).</li><li><strong>-icrnl</strong>: Disable CR->LF translation.</li></ul><p>Setting just these options rather than <code>stty raw</code> should provide (almost) identical output. That should be enough to go through these examples.</p><ol><li><p>In the <code>bash</code> example, <kbd>^C</kbd> still sends the SIGTERM signal despite the <strong>-isig</strong> flag<sup id="footnote-5-indicator"><a href="#footnote-5">5</a></sup>. A new prompt is entered, and the command <code>whoami</code> is entered and executed by pressing <kbd>Enter</kbd>, which actually sends a <kbd>^M</kbd> character that <code>bash</code> translates to <kbd>^J</kbd> despite the <code>-icrnl</code> flag being set. Note that the following prompt is indented; this is due to the <code>-opost</code> flag that is also set by <code>stty raw</code>.</p><p>In the <code>sh</code> equivalent, the story is much simpler. The <kbd>^C</kbd> does not send a signal and is not treated specially. <code>whoami</code> is entered, followed by a <kbd>^M</kbd>, which is also not treated specially. No command is executed becuase <kbd>^J</kbd> is not sent.</p></li><li><p>This one is pretty clear. <code>bash</code> implements its own editing semantics. <code>sh</code> doesn't, and thus the <kbd>^?</kbd> character that is sent when pressing <kbd>Bksp</kbd> is not treated as a special character.</p></li><li><p>Now, we introduce a subprocess spawned by the shell that will read from the terminal. <code>cat -A</code> echoes special characters using the Emacs carat notation.</p><p>In the <code>bash</code> version, after pressing <kbd>Enter</kbd> we execute teh <kbd>cat</kbd> command, and it begins listening for input. The <kbd>cat</kbd> command doesn't implement any line editing like <code>bash</code>, so it simply receives each character from the terminal and echoes it out. Since the terminal is in raw mode, the terminal returns characters one-by-one rather than waiting for the end of the line, hence the repeated characters; it also does not handle <kbd>^C</kbd> and <kbd>Bksp</kbd> specially.</p><p>In the <code>sh</code> version, we might expect the same, except for one caveat: the <kbd>Enter</kbd> command sends <kbd>^M</kbd>, not <kbd>^J</kbd>, so we do not actually execute the <code>cat</code> command. Recall that <kbd>Enter</kbd> doesn't send a newline character if <code>icrnl</code> is disabled.</p></li><li><p>This is almost the same as the previous version, except that we explicitly send <kbd>^J</kbd> rather than <kbd>^M</kbd>/<kbd>Enter</kbd>.</p></li></ol><p>I apologize for going into this much depth in this section, but <code>bash</code>'s behavior profoundly confused me at the beginning. My suggestion for messing around with terminal settings is to work in <code>sh</code> or <code>cat</code>, both of which will not implement line-editing behavior or change terminal settings.</p><hr><h4>In the Linux kernel</h4><ul><li><code>include/linux/tty_ldisc.h</code>: Defines critical data structures <code>struct tty_ldisc</code> and <code>struct tty_ldisc_ops</code>.</li><li><code>drivers/tty/n_tty.c</code>: The default ldisc implementation.</li><li><code>drivers/tty/tty_ldisc.c</code>: ldisc utility functions and wrapper code.</li><li><a href="https://man7.org/linux/man-pages/man3/termios.3.html"><code>termios(3)</code></a>: C API to configure terminal settings using <code>ioctl</code>s.</li><li><a href="https://man7.org/linux/man-pages/man1/stty.1.html"><code>stty(1)</code></a>: Shell command to modify terminal settings; usually simpler than using <code>termios</code>.</li></ul><hr><h4>Resources</h4><ul><li><a href="https://stackoverflow.com/a/44104228">How to read from the terminal "keystrokes buffer"?</a>: A fantastic dive into a particular example of the shell behavior when interacting with the terminal.</li><li><a href="https://stackoverflow.com/q/69198577/2397327">Linux keyboard/terminal/kernel input buffer</a> <code>N_TTY_BUF_SIZE == 4096</code> is the default ldisc buffer size.</li><li><a href="https://man7.org/linux/man-pages/man3/termios.3.html">termios(3) — Linux manual page</a>: Interface to set terminal device settings, such as echo.</li><li><a href="https://stackoverflow.com/a/23317250/2397327">How does input echoing work in a Linux terminal?</a>: Summarizes the many responsibilities of the tty subsystem.</li><li><a href="https://unix.stackexchange.com/questions/414159/behaviour-of-the-backspace-on-terminal">Backspace in the terminal</a></li><li><a href="https://unix.stackexchange.com/questions/401010/prevent-the-line-discipline-from-handling-control-characters">Prevent the line discipline from handling control characters</a></li><li><a href="https://unix.stackexchange.com/questions/239808/how-to-display-control-characters-c-d-differently-in-the-shell">How to display control characters (^C, ^D, ^[, ...) differently in the shell</a></li><li><a href="https://unix.stackexchange.com/questions/719948/does-the-tty-line-discipline-echo-vertical-arrow-keys">Does the tty line discipline echo vertical arrow keys?</a></li><li><a href="https://unix.stackexchange.com/a/367086/307410">Why is the terminal sending a CR even though ICRNL is set?</a></li><li><a href="https://www.cisco.com/c/en/us/td/docs/ios/12_4/cfg_fund/command/reference/cfnapph.html">Appendix: ASCII Character Set and Hexadecimal Values (12.4 CF CR)</a>: List of ASCII codes and corresponding keyboard input (Emacs escape codes)</li><li><a href="http://www.embeddedlinux.org.cn/EssentialLinuxDeviceDrivers/final/ch06lev1sec4.html">Essential Linux Device Drivers: Line Disciplines</a></li><li><a href="http://marcocorvi.altervista.org/games/lkpe/tty/tty.htm">tty layer</a></li></ul><hr><h4>Footnotes</h4><p id="footnote-1"><small><a href="#footnote-1-indicator">1.</a> 4096 characters is a lot of typing... easier to generate a long text file and copy-paste it into stdin.</small></p><p id="footnote-2"><small><a href="#footnote-2-indicator">2.</a> You can also try them in cooked mode without doing <code>stty raw</code> beforehand, although the results will probably be expected. Understanding how the shell interacts in raw mode was the difficult part for me.</small></p><p id="footnote-3"><small><a href="#footnote-3-indicator">3.</a> I am following the Emacs notation for control keys to avoid any ambiguity in the examples shown, as the <kbd>Ctrl</kbd>+<kbd>C</kbd> could look like a sequence of three characters rather than a keyboard combination.</small></p><p id="footnote-4"><small><a href="#footnote-4-indicator">4.</a> If you want to see exactly what <code>bash</code> does, you can run any of the above examples <code>strace bash</code>. Look for <code>ioctl</code>s being sent to the terminal device used to set terminal settings before handling prompt input, and to reset terminal settings before executing a command. When reading the command prompt, <code>bash</code> enables raw mode and disables echoing for the prompt, and handles the raw-mode input directly.</small></p><p id="footnote-5"><small><a href="#footnote-5-indicator">5.</a> Note that in the command prompt, <kbd>^C</kbd> does not send any signal, since no program is currently being executed by the shell. Instead, it cancels the current prompt. In other words, shell programs set a SIGTERM signal handler to cancel the current prompt. This is not relevant to the question at hand, I just found it interesting because it was not something I had thought about previously.</small></p><hr><p>&copy; Copyright 2023 Jonathan Lam</p></body></html>