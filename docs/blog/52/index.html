<!DOCTYPE html><html><head><title>jlam | Understanding memory</title><style>html {
	box-sizing: border-box;
	margin: 0;
	padding: 0.5rem;
}
body {
	max-width: 400pt;
	margin: 0 auto;
	padding: 0;
}</style><link rel="icon" href="/res/favicon.png"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><h1>Jonathan Lam</h1><p>(Recently) Software Engineer @ Google Silicon<br>(Also recently) EE/CS @ The Cooper Union</p><nav><a href="/">Home</a> | <a href="/contact">Contact</a> | <a href="/experience">Experience</a> | <a href="//github.com/jlam55555/resume/raw/master/resume.pdf" target="_blank">Resume</a> | <a href="/blog">Blog</a></nav><hr><!-- inspiration taken from https://codepen.io/Zoxon/pen/WyqdBb--><!-- styles for blog posts--><style>kbd {
	background-color: #eee;
	padding: 0 3px;
	border: 1px solid black;
	border-radius: 2px;
}
blockquote {
	margin: 0;
	background-color: #eee;
	padding: 1px 1em;
}
li {
	margin-block-start: 1em;
	margin-block-end: 1em;
}
h5 {
	font-size: 1em;
	color: #666;
	margin-bottom: 1em;
}
</style><h2>Blog</h2><h3>Understanding memory</h3><p>On 3/6/2023, 8:27:52 PM</p><p><a href="/blog">Return to blog</a></p><hr><p>I spent some time reviewing low-level computer-architecture and performance optimization topics recently, both to brush up on some of the topics from my work at Google, and for interview preparation as I continue my job search. Memory seems to be among the most pertinent of these.</p><p>For now I'll list some of the resources that I was reading, with a brief description of my learning. That being said, these are fantastic readings and I will probably take a long time to get a good handle on the topics they go into detail on, so I may not have a good grasp on them myself yet. I may also add documents later as I continue exploring this space.</p><h4>Overview of memory in Linux</h4><p>My exploration into memory in Linux began with this Drepper paper. It seems to be a highly recommended paper, also <a href="https://lwn.net/Articles/250967/">posted around the same time on LWN</a> and mentioned in the Morin article linked below. <em>This Drepper paper has instantly become one of my favorite papers of all time</em> -- I admire the in-depth technical theory, the practical experiments that demonstrate the theory and further understanding, and the clarity of speech (which seems to owe a lot to Jonathan Corbet, a regular poster of fantastic LWN articles).</p><ul><li><a href="https://www.akkadia.org/drepper/cpumemory.pdf">What every programmer should know about memory</a> (Drepper, 2007): A fantastic overview of memory in Linux. This interleaves useful knowledge (designed for the programmer) about the hardware with practical examples running on commodity and server hardware. It dives deep into many relevant topics surrounding memory, especially but not limited to: memory hardware, caching, virtualization/paging, CPU and memory subsystem topology (e.g., NUMA factors), hardware/software prefetching, effects of SMT/MT/SMP, TLB/page fault optimization, etc. It's 15 years old but still very relevant: see <a href="https://stackoverflow.com/a/47714514">this Stack Overflow post</a> for more details on its modern relevance.</li><li><a href="https://www.hudsonrivertrading.com/hrtbeat/low-latency-optimization-part-1/">Low latency optimization: understanding huge pages</a> (Morin, 2022): This was what brought me to the Drepper paper in the first place, as I was exploring the high frequency trading space. After reading the Drepper paper, huge pages make sense for many reasons, but it wasn't recommended at that time (2007). But memory capacity has increased since then and high-frequency trading is extremely performance-critical, so this article shows that this optimization is very useful with practical experiments.</li></ul><h4>Memory consistency and cache coherence</h4><p>I wanted to study these problems because they are very relevant in low-level programming in general. Referencing the definitions provided by the Sorin et al. paper listed below, we can define these problems roughly as: <em>consistency</em>: the correctness of shared memory and the (observed) order of loads and stores; <em>coherence</em>: the correctness of unshared caches. Coherence is generally required to have consistency, as (generally) all loads and stores go through the cache.</p><p>I encountered these issues at my time in Android because we dealt with an incoherent memory subsystem and ARM has a relaxed memory ordering. It's not too useful in my everyday programming given that x86_64 tends to be strongly ordered and many memory subsystems are coherent, but it's good to know and understand<sup id="footnote-1-indicator"><a href="#footnote-1">1</a></sup>.</p><p>Memory consistency in particular was especially confusing to me: it didn't seem to make sense that different CPUs could see the same memory writes in different orders. But it turns out that there are many different observers of memory operations: "source code order," program order, execution order, and "observed order" (by other CPUs). Source code order may differ from program order (the compiled assembly) due to compiler optimizations; program order may differ from execution order due to out-of-order execution (pipelining) optimizations; and execution order may differ from the order that other CPUs view the memory due to second-order effects such as a cache store buffer (see <a href="https://stackoverflow.com/a/70749413/2397327">this Stack Overflow answer</a> for more details). These optimizations can be disabled by providing stricter memory ordering hints (i.e., <code>std::memory_order</code> hints to operations on <code>std::atomic</code>s, or directly calling memory fence instructions).</p><ul><li><a href="https://course.ece.cmu.edu/~ece847c/S15/lib/exe/fetch.php?media=part2_2_sorin12.pdf">A primer on memory consistency and cache coherence</a> (Sorin, Hill, and Wood, 2011): I haven't read the whole thing, but this provides a good outline on the titular problems.</li><li><a href="https://www.youtube.com/watch?v=A_vAG6LIHwQ">Atomic's memory orders, what for?</a> (Birbachar, 2017): A practical walkthrough of different memory orders supported by the C++ <code>std::atomic&lt;T&gt;</code> standard. I.e., explains relaxed vs. release/acquire vs. sequential consistency memory orders<sup id="footnote-2-indicator"><a href="#footnote-2">2</a></sup> with some practical examples. He also clearly explains the difference between sequence points, synchronization, and happens-before relationships, giving a pretty good overall view on synchronization (again, with practical examples in C++).</li></ul><h4>Synchronization (atomics and futexes)</h4><p>This study of futexes was born out of a desire to learn more about how synchronization primitives and atomics (at least in C++) are developed. The very high-level summary of my findings is this: all synchronization primitives and atomics are based on atomic CPU instructions, especially Compare-And-Swap (CAS). (Note that this works by temporarily pausing the MESI protocol in the caches). <code>std::atomic</code> is directly built on top of this, as well as lock-less data structures.</p><p>When a thread may need to wait/sleep to synchronize, Linux provides the futex (Fast Userspace mutEXES) API<sup id="footnote-3-indicator"><a href="#footnote-3">3</a></sup>, which is a generalization of (and is used to implement both) mutexes and condition variables. Note that futexes still use CAS to manage state atomically, and may transfer control to the kernel if the thread needs to block. Futexes also require a kernel waitqueue implementation that cause a quick wakeup for waiting threads upon signalling a futex.</p><p>Now, C++'s <code>std::atomic&lt;T&gt;</code> is actually more powerful than simply providing atomic access to their contents (of type <code>T</code>). It turns out that synchronization atomics are much more useful for synchronization if they also provide memory ordering semantics<sup id="footnote-4-indicator"><a href="#footnote-4">4</a></sup>; this is explained in more detail by Birbachar's talk linked above.</p><ul><li><a href="https://eli.thegreenplace.net/2018/basics-of-futexes/">Basics of futexes</a> (Bendersky, 2018): A brief overview to the futex API. It's probably good to also read the <a href="https://man7.org/linux/man-pages/man2/futex.2.html">futex (2)</a> manpage, but I haven't gotten through that yet.</li><li><a href="https://dept-info.labri.fr/~denis/Enseignement/2008-IR/Articles/01-futex.pdf">Futexes are tricky</a> (Drepper, 2004): Referenced by the Bendersky article, this shows a basic implementation of a mutex using the futex interface. The implementation is indeed tricky.</li><li><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">Double-Checked Locking is Broken</a> (Bacon et al., ~1999): While we're on the topic of locking, I wanted to read this paper recommended to me by my former tech lead at Google. This issue arises due to the <a href="https://en.wikipedia.org/wiki/Java_memory_model">JMM</a> and the pre-Java1.5 inability to add explicit memory fences or control memory order like in C++. Note that this issue is fixed after Java1.5 added the <code>volatile</code> keyword, which <a href="https://stackoverflow.com/a/13688818/2397327">provides a functionality similar to <code>std::atomic</code> with memory barriers by default</a>. Like the above Drepper paper, this is a case of a non-trivial synchronization bug. It acts as a great brain-teaser!</li></ul><hr><h4>Footnotes</h4><p id="footnote-1"><small><a href="#footnote-1-indicator">1.</a> Sorin et al. make the distinction that memory consistency is important for the programmer to get right when dealing with shared memory and concurrency, whereas coherence is usually a problem abstracted away by the hardware.</small></p><p id="footnote-2"><small><a href="#footnote-2-indicator">2.</a> My reductive rundown of memory orders: <em>relaxed</em> memory order doesn't guarantee anything; <em>release/acquire</em> semantics orders memory operations w.r.t. a single <code>std::atomic</code>; and <em>sequential consistency</em> <a href="https://stackoverflow.com/a/12340924/2397327">gives a total order for all <code>std::atomic</code>s</a> (that doesn't contradict the program order for any single thread).</small></p><p id="footnote-3"><small><a href="#footnote-3-indicator">3.</a> Wherever you find an article detailing the motivation for futexes, the stated motivation for futexes is that they are faster than the previous POSIX mutex synchronization mechanism. This old mutex required a switch into kernel mode, which was expensive especially when the lock was uncontested and a single CAS operation would do. This explanation makes sense to me, but I can't really find any other information on these old POSIX mutexes for some reason; modern <a href="https://github.com/lattera/glibc/blob/master/nptl/pthread_mutex_lock.c#L168">POSIX mutexes seem to be based on futexes</a>.</small></p><p id="footnote-4"><small><a href="#footnote-4-indicator">4.</a> By default, the default memory ordering for <code>std::atomic</code> load/stores is sequential consistency (<code>std::memory_order::seq_cst</code>). If we only needed purely atomic behavior and didn't care about the relative memory ordering of other variables, then we can use <code>std::memory_order::relaxed</code>.</small></p><hr><p>&copy; Copyright 2023 Jonathan Lam</p></body></html>