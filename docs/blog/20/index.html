<!DOCTYPE html><html><head><title>jlam | SICP notes: types of polymorphism</title><style>html {
	box-sizing: border-box;
	margin: 0;
	padding: 0.5rem;
}
body {
	max-width: 400pt;
	margin: 0 auto;
	padding: 0;
}</style><link rel="icon" href="/res/favicon.png"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><h1>Jonathan Lam</h1><p>(Recently) Software Engineer @ Google Silicon<br>(Also recently) EE/CS @ The Cooper Union</p><nav><a href="/">Home</a> | <a href="/contact">Contact</a> | <a href="/experience">Experience</a> | <a href="//github.com/jlam55555/resume/raw/master/resume.pdf" target="_blank">Resume</a> | <a href="/blog">Blog</a></nav><hr><!-- inspiration taken from https://codepen.io/Zoxon/pen/WyqdBb--><!-- styles for blog posts--><style>kbd {
	background-color: #eee;
	padding: 0 3px;
	border: 1px solid black;
	border-radius: 2px;
}
blockquote {
	margin: 0;
	background-color: #eee;
	padding: 1px 1em;
}
li {
	margin-block-start: 1em;
	margin-block-end: 1em;
}
h5 {
	font-size: 1em;
	color: #666;
	margin-bottom: 1em;
}
</style><h2>Blog</h2><h3>SICP notes: types of polymorphism</h3><p>On 6/13/2021, 8:29:55 AM</p><p><a href="/blog">Return to blog</a></p><hr><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-zc7WDnCM3aom2EziyDIRAtQg1mVXLdILE09Bo+aE1xk0AM2c2cVLfSW9NrxE5tKTX44WBY0Z2HClZ05ur9vB6A==" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" integrity="sha512-vswe+cgvic/XBoF1OcM/TeJ2FW0OofqAVdCZiEYkd6dwGXthvkSFWOoGGJgS2CW70VK5dQM5Oh+7ne47s74VTg==" crossorigin="anonymous"><style>pre {
	padding: .5rem !important;
	line-height: 1 !important;
}
code.fancy-code {
	line-height: 1 !important;
	font-size: 0.75rem !important;
	tab-size: 8 !important;
}
</style><p>When writing <a href="/blog/19">the previous post</a>, I realized that I didn't really understand what polymorphism or generic procedures are, and I was a little afraid to use the terms incorrectly. Here I will try to consolidate what I understand to be their definitions, and various subtypes of polymorphism, with my own examples.</p><p>The problem I have with understanding these terms is that most definitions immediately jump to OOP as an example. While the OOP structure certainly has textbook examples in polymorphism, it is a bad definition for those who want to understand the general concept (i.e., in the spirit of <em>SICP</em>).</p><p>First things first -- what is a <em>data type</em> (or simply "type")? We have to distinguish between an <em>abstract data type</em> (ADT) and a <em>concrete data type</em>. An ADT is a description of an interface of a particular kind of data, such as a stack or queue, but it can be implemented in several different ways by different concrete data types. In this post (as in the previous post<sup id="footnote-2-indicator"><a href="#footnote-2">2</a></sup>), we'll potentially need to differentiate between multiple implementations of the same ADT. Note also that we are using the term "interface" very loosely -- unlike the very concrete meaning it has in Java and TypeScript and some other OOP languages, I mean it in the most general sense.</p><p>Using Wikipedia's definition<sup id="footnote-3-indicator"><a href="#footnote-3">3</a></sup> <em>polymorphism</em> is "the provision of a single interface to entities of different types or the use of a single symbol to represent multiple different types." These might seem like two very different things, but we can invoke the wand of the Wizard Book and say that the boundary between procedures and data is somewhat fuzzy. Both provide an "interface"<sup id="footnote-4-indicator"><a href="#footnote-4">4</a></sup>, and if these interfaces can handle multiple types, then the procedure or datum is polymorphic.</p><p>This is an extremely broad definition and it applies to many things. We can characterize polymorphism in several ways<sup id="footnote-5-indicator"><a href="#footnote-5">5</a></sup>:</p><ul><li><em>Procedural vs. data</em>: This classification is most apparent from the definition. A procedure is polymorphic if a single function name can support several different data types as input. This may require several implementations (ad-hoc) or a single implementation (parametric or subtyping). Data can be parametric in two senses: it is a generic template that can store different types of data, such as container types (parametric); and when a single variable can act as if it is of a different type, usually a supertype (subtyping). Another way to understand data polymorphism is to use the message passing interpretation of an object<sup id="footnote-6-indicator"><a href="#footnote-6">6</a></sup>, and say that an object is polymorphic if its dispatch method is polymorphic.</li><li><p><em>Ad-hoc vs. parametric vs. subtyping</em>: Ad-hoc and parametric polymorphism were the two major classes of polymorphisms described by Christopher Strachey in <em>Fundamental Concepts in Programming Languages</em>. Later, with the development of hierarchical polymorphism like the language Simula, the third class was added.</p><p><em>Ad-hoc polymorphism</em> occurs when multiple different implementations of a function are written to handle different types, and is the form commonly seen in method overloading. This is usually compile-time dispatch.</p><p><em>Parametric polymorphism</em> occurs when a single procedure or data type implementation can be written <em>generically</em> or "uniformly" but can handle different data types correctly. This is exemplified by what Java calls generics and what C++ calls templates. We write one method or class (type) that has a "type parameter" -- a placeholder for a type so that we can use this method or class with any concrete type that matches this type's parameter's interface<sup id="footnote-7-indicator"><a href="#footnote-7">7</a></sup>. This is usually compile-time dispatch.</p><p>Lastly, <em>subtype polymorphism</em> occurs when there is an inherent hierarchy of types, and a method implementation on a type can be shadowed (overridden) by an implementation on a subtype. When calling a method on an object, we need to determine which implementation to call. This is what I typically hear when talking about polymorphism, but it mostly is limited to OOP languages. This is usually dynamic dispatch.</p><p>These definitions are not mutually disjoint. For example, we can have an overloaded method that overrides a superclass method in Java: here, it knows which of the overloaded method signatures to use at compile-time (ad-hoc), but it uses dynamic dispatch (subtype) on the object to know which implementation in the type hierarchy to call.</p><p>If these definitions don't make that much sense to you, then <a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">the Wikipedia page on polymorphism</a> has a really good explanation of all three types.</p></li><li><em>Dynamic (run-time) vs. compile-time dispatch</em> This is when the correct implementation of a polymorphic interface is chosen, and has obvious implications on the performance and flexibility of polymorphism. If type can be inferred at compile-time (e.g., with method overloading or when using templates), we know which version of a function to call. But sometimes, we cannot infer the type of a variable at run-time, and this is common when using subclassing, with the following textbook example (using pidgeon Java):<pre><code class="fancy-code language-java">interface Parent {
	func foo();
}
class Child1 implements Parent {
	@Override
	func foo() {
		print("in child 1");
	}
}
class Child2 implements Parent {
	@Override
	func foo() {
		print("in child 2");
	}
}
class Main {
	func main() {
		Parent[] p = {new Child1(), new Child2()};
		p[0].foo();	// => "in child 1" 
		p[1].foo();	// => "in child 2"
	}
}</code></pre><div>In this example, we are calling the <code>foo()</code> method on an object of type <code>Parent</code>, but we don't know which implementation of <code>Parent</code> (and thus which implementation of <code>foo</code>) should be called. (This fact is more obvious if the array <code>p</code> is generated at run-time, e.g., created with user input.) So the JVM has to dynamically find the correct implementation at run-time<sup id="footnote-8-indicator"><a href="#footnote-8">8</a></sup>. Note that if we are prototyping a type system, as we do in <em>SICP</em>, we cannot perform compile-time polymorphism (but that is also not our goal).</div></li><li><em>Single- vs. multi-dispatch</em> This deals with dynamic dispatch with procedural polymorphism<sup id="footnote-9-indicator"><a href="#footnote-9">9</a></sup>. In OOP languages with subtype polymorphism, we usually see <em>single dispatch</em>: we call a method <em>on</em> an object, and the dynamic-dispatch polymorphism uses the object only (to decide which implementation to call) and not to any (other<sup id="footnote-10-indicator"><a href="#footnote-10">10</a></sup>) parameters. But we may want a procedure to be polymorphic for multiple or all of its operands, and this is called <em>multiple dispatch.</em> We implemented a very basic form of multiple dispatch in <em>SICP</em> by simply iterating through all the possible coercions of all the arguments to try to find an appropriate conversion<sup id="footnote-11-indicator"><a href="#footnote-11">11</a></sup>. Some languages support multiple dispatch natively, such as Common Lisp, Julia, and Raku (Perl).</li></ul><p>To illustrate some of these examples in a less-conventional context, we can use the examples from <em>SICP</em>, which use both ad-hoc and parametric (generic) polymorphism (although the authors do not use these names). Consider the following two functions from section 2.4:</p><pre><code class="fancy-code language-scheme">(define (cplx-real-part z)
  ;; get the real part of a number
  (cond ((cplx-rectangular? z) 
	 (cplx-real-part-rectangular (contents z)))
	((cplx-polar? z)
	 (cplx-real-part-polar (contents z)))
	(else (error 'cplx-real-part "Unknown type" z))))

(define (complex+ z1 z2)
  ;; add two complex numbers
  (make-from-real-imag (+ (cplx-real-part z1)
			  (cplx-real-part z2))
		       (+ (cplx-imag-part z1)
			  (cplx-imag-part z2))))</code></pre><p><code>cplx-real-part</code> uses ad-hoc dynamic single-dispatch polymorphism -- we define separate implementations to handle different types. In a language with overloading support, this would most likely be compile-time polymorphism. <code>complex+</code>, on the other hand, is a generic function. Because <code>z1</code> and <code>z2</code> both implement the <code>cplx-real-part</code> and <code>cplx-imag-part</code> interface, we don't have to write multiple versions of <code>complex+</code>. Note that this is closely tied to the notion of <em>abstraction barriers</em>, as Abelson and Sussman call it: because we define the lower-level interface <code>cplx-real-part</code> and <code>cplx-real-part</code>, higher-level interfaces can use this interface generically. However, we do need to implement these for each underlying representation, and that is where the ad-hoc polymorphism comes in.</p><p>Later on, in section 2.5 when Abelson and Sussman extend this system to another level of abstraction by implementing the arithmetic system, we see another level of ad-hoc polymorphism: each algebraic field must register their implementation of the add, subtract, multiply, and divide in the dispatch table. There, we implement a very simple version of multiple dispatch and the authors suggest a coercion and a hierarchy, which might introduce a subtype polymorphism system.</p><p>One last important note to make about <em>SICP</em>'s suggested hierarchy system: unlike typical hierarchical systems where we look to a superclass for an implementation, in the most general sense we can also look to subclasses for an implementation. This would require narrowing (downcasting) the type to that of one of its subclasses (or perhaps it may not be considered a hierarchy at all, but some other type of relation) which is typically an error in hierarchical systems, but it is an alternative design<sup id="footnote-12-indicator"><a href="#footnote-12">12</a></sup>.</p><hr><h4>Miscellaneous topics</h4><p>Polymorphism was the main confusion point for me when looking up details of type systems, but here are some other notes that stemmed from writing the previous post:</p><ul><li><a href="https://en.wikipedia.org/wiki/Duck_typing"><em>Duck typing</em></a> is another "implementation" of polymorphism. This means that we can handle objects without type restriction, and determine their effective type based on properties of the object. In particular, languages that allow untyped objects (such as Lisp, or Javascript, in which value acts like an dictionary and an object) tend to use duck typing. Related to a previous footnote, the C++ template system is actually implemented like a <a href="https://en.wikipedia.org/wiki/Duck_typing">compile-time duck-typing</a>.</li><li>I'm not really sure how variadic functions fit into the model of method overloading and overriding. I'm assuming that the variadic arguments form part of the method signature, but I have a vague thought that they can be used to make a statically-typed language a lot more dynamic. On an aside, I absolutely love the "dotted-tail" notation used for varargs in Scheme -- it feels as if the code is performing pattern-matching on expressions.</li><li>Overloading vs. overriding. This was already covered, but the similarity of the names sometimes gets me. Overloading is a form of ad-hoc polymorphism, and overriding is a form of subtype polymorphism.</li><li>Abelson and Sussman mention the difficulties of multiple inheritance, but some languages support it anyways, such as Python and C++. Java gets around this a little bit by introducing the interface language construct and allowing multiple inheritance of interfaces, but only single inheritance of another class. This means that each class can only have one upstream implementation of a method. However, interfaces make the language more bloated (makes the terms "subclassing" and "inheritance" mean separate ideas) and can be confusing for beginners when there's also abstract classes.</li></ul><hr><h4>Footnotes</h4><p id="footnote-1"><small><a href="#footnote-1-indicator">1.</a> I.e., sets of objects that can be added, subtracted, multiplied, and divided commutatively. They used complex numbers, reals, rationals, polynomials, and rational functions.</small></p><p id="footnote-2"><small><a href="#footnote-2-indicator">2.</a> We had to differentiate between different implementations of the complex number interface, and between several implementations of the algebraic field<sup id="footnote-1-indicator"><a href="#footnote-1">1</a></sup> interface.</small></p><p id="footnote-3"><small><a href="#footnote-3-indicator">3.</a> Most of these definitions will come from Wikipedia, but I'll try to explain the definitions in my own words.</small></p><p id="footnote-4"><small><a href="#footnote-4-indicator">4.</a> The interface of a procedure is the set of arguments it takes and the values it returns, and the interface of a datum is the set of arguments it[s constructors and methods] take(s) and the values it[s selectors and methods] return(s).</small></p><p id="footnote-5"><small><a href="#footnote-5-indicator">5.</a> Of course, this list is neither absolute nor complete, and you may find many other characterizations online. This is only my own list based on the concepts that were useful for understanding the type concepts introduced in <em>SICP</em> 2.5. I also don't have a name for each characterization.</small></p><p id="footnote-6"><small><a href="#footnote-6-indicator">6.</a> <em>SICP</em> section 2.4</small></p><p id="footnote-7"><small><a href="#footnote-7-indicator">7.</a> This last point is a little dependent on implementation: in C++, templates are instantiated separately for each class it is compiled on, which is a pain point for the programmer because the template depends on the applied types. This breaks separate compilation. However, in Java, we can have separate compilation because the parameter type is enforced by restrictions on the type parameter. See more <a href="https://stackoverflow.com/a/35173219/2397327">here</a>, and see the section in this post about duck typing.</small></p><p id="footnote-8"><small><a href="#footnote-8-indicator">8.</a> As far as I know, this is the way subclassing is implemented in other languages as well.</small></p><p id="footnote-9"><small><a href="#footnote-9-indicator">9.</a> This only applies when you have multiple arguments, which wouldn't happen with data polymorphism you consider the message-passing model with multiple operations ("messages"). But I don't have an example of this in mind.</small></p><p id="footnote-10"><small><a href="#footnote-10-indicator">10.</a> I say other because methods are usually implemented with an implicit <code>this</code> or <code>self</code> parameter, on which the polymorphism applies.</small></p><p id="footnote-11"><small><a href="#footnote-11-indicator">11.</a> This has multiple problems but is a simple illustration of multiple dispatch.</small></p><p id="footnote-12"><small><a href="#footnote-12-indicator">12.</a> See <a href="https://en.wikipedia.org/wiki/Is-a">is-a relationships</a>. I believe this is the typical semantic interpretation of subclassing, and in its perspective downcasting doesn't make sense. Downcasting also probably violates the Liskov substitution principle, but I don't know much about that.</small></p><hr><p>&copy; Copyright 2023 Jonathan Lam</p></body></html>