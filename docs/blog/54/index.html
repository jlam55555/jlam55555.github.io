<!DOCTYPE html><html><head><title>jlam | The Linux tty subsystem</title><style>html {
	box-sizing: border-box;
	margin: 0;
	padding: 0.5rem;
}
body {
	max-width: 400pt;
	margin: 0 auto;
	padding: 0;
}</style><link rel="icon" href="/res/favicon.png"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><h1>Jonathan Lam</h1><p>(Recently) Software Engineer @ Google Silicon<br>(Also recently) EE/CS @ The Cooper Union</p><nav><a href="/">Home</a> | <a href="/contact">Contact</a> | <a href="/experience">Experience</a> | <a href="//github.com/jlam55555/resume/raw/master/resume.pdf" target="_blank">Resume</a> | <a href="/blog">Blog</a></nav><hr><!-- inspiration taken from https://codepen.io/Zoxon/pen/WyqdBb--><!-- styles for blog posts--><style>kbd {
	background-color: #eee;
	padding: 0 3px;
	border: 1px solid black;
	border-radius: 2px;
}
blockquote {
	margin: 0;
	background-color: #eee;
	padding: 1px 1em;
}
li {
	margin-block-start: 1em;
	margin-block-end: 1em;
}
h5 {
	font-size: 1em;
	color: #666;
	margin-bottom: 1em;
}
</style><h2>Blog</h2><h3>The Linux tty subsystem</h3><p>On 4/7/2023, 5:30:04 PM</p><p><a href="/blog">Return to blog</a></p><hr><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-zc7WDnCM3aom2EziyDIRAtQg1mVXLdILE09Bo+aE1xk0AM2c2cVLfSW9NrxE5tKTX44WBY0Z2HClZ05ur9vB6A==" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" integrity="sha512-vswe+cgvic/XBoF1OcM/TeJ2FW0OofqAVdCZiEYkd6dwGXthvkSFWOoGGJgS2CW70VK5dQM5Oh+7ne47s74VTg==" crossorigin="anonymous"><style>pre {
	padding: .5rem !important;
	line-height: 1 !important;
}
code.fancy-code {
	line-height: 1 !important;
	font-size: 0.75rem !important;
	tab-size: 8 !important;
}
</style><h4>Preface</h4><p>This is my attempt at understanding terminal devices in Linux, both from a summary perspective and from an implementation perspective (for my OS project). This is the result of roughly two days of frantic Internet searching, and was originally written as part of my OS project documentation<sup id="footnote-1-indicator"><a href="#footnote-1">1</a></sup>.</p><hr><h4>What is a terminal device?</h4><p>The terminal is an abstraction used to manage I/O from a serial device. In its simplest form, let's assume we have a single keyboard, and a non-multitasking computer (only running one process at any time, and this process is in the foreground). Then, the terminal acts as the interface between the user and the process.</p><pre><code class="fancy-code language-text">                  --< screen <--- (stdout)
                 /               \
user (master) <--    TERMINAL     --> process (slave)
                 \               /
                  --> keyboard -- (stdin)</code></pre><p>This is all a terminal is. It has a "master" (interactive) and a "slave" (process) side, and two queues (one for input and one for output). The master side can have some additional functionality, such as sending signals to the slave. Like a pipe, both sides can write to the file: output on one side becomes input on the other.</p><p>In the old days, there were physical terminals (teletype machines, or tty), which were machines used to input data to and display output from mainframes, and the upper and lower lines were two pairs of physical wires (RX/TX). Now, we tend to abstract away terminals into Linux devices files, but the name tty persists.</p><hr><h4>Virtualization</h4><p>The picture becomes muddier once we add in some additional variables:</p><ol><li><p>Multiple serial input devices?</p></li><li><p>Multiple process sessions for one screen?</p></li><li><p>Multiple processes or multiple devices attached to one terminal?</p></li><li><p>Emulated (non-physical) master device?</p></li></ol><p>Addressing these issues:</p><ol><li><p>We can simply allow multiple terminals. Each terminal is implemented in Linux as a device file (in devfs), and processes can read to/write from any of these files as if they were regular files.</p></li><li><p>This leads us to multiplex (virtualize) the screen. The <em>virtual terminal </em>(vt) driver does this, multiplexing the screen over seven different physical terminals (<code>/dev/tty[1-7]</code>), each running their own session (shell). The keyboard is only "connected" to the active terminal session.</p></li><li><p>This leads us to multiplex the master and/or the slave side of a terminal. GNU <code>screen </code>is the prototypical example of this, turning the single-channel semantics into a broadcast semantics when multiple processes connect to the same terminal device.</p></li><li><p>We may want to create a terminal where the master side input does not come from a physical device (i.e., directly from the keyboard driver). Without going into too much depth, this is used in graphical modes like <a href="http://X.org">X.org </a>to implement <em>terminal emulators</em>. In <a href="http://X.org">X.org</a>, keyboard input from the physical terminal are turned into X events at <code>/dev/event*</code>, and sent to the foreground application. A terminal emulator like <code>xterm </code>may want to use this to emulate the master device of a terminal. To do this, it can use the <em>pseudoterminal </em>(pty) driver to create a master-slave pair, such that events written to the master side emulate a physical device master.</p></li></ol><hr><h4>Updated diagram</h4><p>On the left, we have what is more or less the pty driver stack; on the right we have the vt driver stack.</p><pre><code class="fancy-code language-text">   Graphical mode/pseudoterminal       : Text mode/physical terminal
                                       :
+----------------+ +---------------+   :   +---------------+
| /usr/bin/xterm | | /usr/bin/bash |   :   | /usr/bin/bash |
|                | |               |   :   |               |
| terminal       | | process       |   :   | process       |
| emulator       | +---------------+   :   +---------------+
+----------------+    ^                :      ^
   ^                  |                :      |
   |                  v                :      v
   |               +--------------+    :   +--------------+
   |               | /dev/pts/3   |    :   | /dev/tty5    |
   |               |              |    :   |              |
   |               | pty tty      |    :   | vt tty       |
   |               | slave device |    :   | slave device |
   |               +--------------+    :   +--------------+
   |  **********      ^                :      ^
   | *xorg magic*     |                :      |
   |/ ********** \    v                :      v
   |            +--------------------------------------------------+
   |            | tty line discipline/other core editing utilities |
   |            +--------------------------------------------------+
   |              ^                    :      ^
   |             /                     :      |
   v            v                      :   +---------------+
+---------------+                      :   | keyboard IRQ  |
| /dev/ptmx     |                      :   |               |
|               |                      :   | vt tty        |
| pty tty       |                      :   | master device |
| master device |                      :   +---------------+
+---------------+                      :
</code></pre><p>I got tired of the ascii art around the X.org magic part. X.org manages a single virtual terminal (which we can think of as something like <code>/dev/tty7</code>, continuing the <code>vt </code>analogy). Keyboard events are signalled to the foreground process using <code>/dev/event*</code>, which are sent to the pty tty master device.</p><hr><h4>Terminology</h4><ul><li><p><strong>Terminal</strong>: An abstract device that implements a bidirectional master/slave I/O channel.</p></li><li><p><strong>Physical terminal (tty)</strong>: Refers to a terminal device connected to a physical device, e.g., a serial port; now, "tty" is loosely used to refer to the subsystem in general and to terminal devices in general.</p></li><li><p><strong>Virtual terminal (vt)</strong>: Driver that multiplexes the text-mode display over multiple terminal devices, and performs text-mode rendering; provides the text-mode terminals usually found at <code>/dev/tty[1-6] </code>or  <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd> through <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F6</kbd>.</p></li><li><p><strong>System console</strong>: Usually refers to the text-mode terminal used for kernel space processes (i.e., calls to <code>printk() </code>get printed here, and this can usually be found at <code>/dev/tty1</code>).</p></li><li><p><strong>Pseudoterminal (pty)</strong>: Driver that provides a master/slave terminal device file pair (as opposed to a physical terminal, where the master device is usually implemented as a hardware driver); allows the use of a non-physical device as the terminal master, e.g., in userspace graphical mode.</p></li><li><p><strong>Terminal emulator </strong>(e.g., <code>xterm</code>) : A program running in graphical mode that provides an interface similar to a program running in a text-mode terminal using a pseudoterminal. In some ways, this is the graphical mode equivalent of a virtual terminal, and some people also call these programs virtual terminals.</p></li><li><p><strong>Terminal multiplexer </strong>(e.g., GNU <code>screen</code>) : Allow multiple processes to connect to a single terminal device (multi-channel terminal); i.e., reads and writes are broadcasted rather than being sent to a single process.</p></li><li><p><strong>Shell </strong>(e.g., <code>bash</code>): An interactive text-mode application that uses a terminal device for I/O; prompts user for commands to run and executes them, displaying their output. Shells aren't really related to this discussion, but sometimes conflated with the term "terminal".</p></li></ul><hr><h4>Use cases of tty</h4><p>The tty interface can be used whenever you have a situation similar to the motivating scenario. Examples are the <code>ssh </code>and <code>telnet </code>commands, which are interactive sessions to some external computer. In this case, the slave process is not a local process, but rather a shell process (<code>ssh</code>) or some process writing to a port (<code>telnet</code>) on an remote machine.</p><hr><h4>tty subsystem in the Linux source code</h4><ul><li><p><code>include/linux/tty.h</code>: Defines essential data structures related to a tty device, such as <code>struct tty_struct</code>.</p></li><li><p><code>include/linux/tty_driver.h</code>: Defines essential data structures for a tty driver implementer (such as vt and pty), such as <code>struct tty_driver </code>and <code>struct tty_operations</code>.</p></li><li><p><code>drivers/tty/vt/vt.c</code>: Defines a <code>struct tty_driver </code>for the six multiplexed text-mode physical terminal devices; provides the <code>/dev/tty* </code>slave device files.</p></li><li><p><code>drivers/tty/pty.c</code>: Defines a <code>struct tty_driver </code>for the <code>/dev/ptmx</code>/<code>/dev/pts/* </code>master/slave device files.</p></li></ul><hr><h4>Thought exercise: who does the rendering? And how do we echo?</h4><p>This simple question stumped me for a little bit while I was trying to understand how the terminal works, and it was difficult to find an easy-to-swallow answer online. In text mode, who manages the rendering of the terminal text? And how do we manage the echo/noecho functionality (i.e., show or hide input from the master side)?</p><p>(Note: I'm not sure if the following answers are correct, these are just the conclusions that I've logically come to.)</p><p>Well, the master side is the one interacting with the system, and the one that wants to see the input and output to the process. The process doesn't need to render any of its I/O for to behave correctly; it is the human that needs it. So the master side manages any rendering, and can decide to turn off any rendering if need be.</p><p>In the case of the system console, the master side of the <code>vt </code>driver renders data (using the VGA framebuffer) from the output queue when output is generated from the slave side. In the case of a graphical-mode terminal emulator, the master side (e.g., <code>xterm </code>connected to <code>/dev/ptmx</code>) renders likewise (albeit using <X class="org">drawing commands).</X></p><p>Then, what about displaying keyboard data from the master side? (I.e., how do we implement echoing?) We can do this by "echoing" (copying) the input stream onto the output queue. This is a change at the <code>tty </code>device level rather than the <code>vt</code>/<code>ptmx </code>driver level. (In Linux, I do not see any handling of echo in the <code>vt</code>/<code>ptmx </code>drivers, so I assume that it is performed in the <code>tty </code>device layer in this way.)</p><hr><h4>Special editing semantics</h4><p>While tty devices are mostly a "dumb" device, there are a few editing semantics that make sense for the interactive asymmetric terminal interface. This special behavior is transmitted using special (ascii) characters or character sequences from the keyboard, such as <kbd>Ctrl</kbd>+<kbd>C</kbd> (ascii code 3) or <kbd>Bksp</kbd> (ascii code 8). I won't go into these in detail here, these are explained well in other articles, and I don't find them terribly useful to understanding the core of the tty subsystem.</p><ol><li><p><strong>Line discipline</strong>: This allows for some editing of the buffer by using special characters such as <kbd>Bksp</kbd>.</p></li><li><p><strong>Signals</strong>: The master side can send POSIX signals (e.g., SIGHUP, SIGTERM) to the process using special characters such as <kbd>Ctrl</kbd>+<kbd>C</kbd>.</p></li><li><p><strong>VT100 display codes </strong>(a.k.a., ANSI escape codes): Used to manipulate the rendering of the output, such as moving the cursor, coloring the screen, etc. There are some newer standards, e.g., VT220.</p></li></ol><hr><h4>Resources</h4><p>Wikipedia links to the major terminology words are also recommended but not included below, because you can find those yourself.</p><ul><li><p><a href="http://www.linusakesson.net/programming/tty/">The TTY demystified</a>: Highly recommended by many people. Provides a general overview of the tty subsystem, and especially talks about line discipline and signals.</p></li><li><p><a href="https://unix.stackexchange.com/q/117981/307410">What are the responsibilities of each Pseudo-Terminal (PTY) component (software, master side, slave side)?</a>: Many fantastic answers about tty in general, line discipline, and the pty master/slave relationship.</p></li><li><p><a href="https://www.reddit.com/r/osdev/comments/hgzg6k/comment/fwabf1j/?utm_source=reddit&amp;utm_medium=web2x&amp;context=3">TTY questions</a>: Some considerations when designing a tty implementation.</p></li><li><p><a href="https://stackoverflow.com/q/69198577/2397327">Linux keyboard/terminal/kernel input buffer</a>: How large is the tty buffer? This suggests <code>N_TTY_BUF_SIZE == 4096 </code>is the maximum buffer size (see <code>drivers/tty/n_tty.c</code>).</p></li><li><p><a href="https://stackoverflow.com/q/24024985/2397327">Linux keyboard/terminal/kernel input buffer</a>: Motivates a terminal multiplexer like GNU <code>screen</code>.</p></li><li><p><a href="https://stackoverflow.com/q/48627344/2397327">Linux keyboard/terminal/kernel input buffer</a>: Another Internet user trying to figure out how the tty subsystem works.</p></li><li><p><a href="https://man7.org/linux/man-pages/man3/termios.3.html">termios(3) — Linux manual page</a>: Interface to set terminal device settings, such as echo.</p></li><li><p><a href="https://stackoverflow.com/a/23317250/2397327">How does input echoing work in a Linux terminal?</a>: Summarizes the many responsibilities of the tty subsystem.</p></li><li><p><a href="https://unix.stackexchange.com/a/138390/307410">How to read/write to tty* device?</a>: Provides some examples of how to use <code>/dev/tty </code>files.</p></li><li><p><a href="https://unix.stackexchange.com/q/21147/307410">What are pseudo terminals (pty/tty)?</a>: Gives a simple explanation of pty.</p></li><li><p><a href="https://unix.stackexchange.com/q/404555/307410">What is the purpose of the controlling terminal?</a>: Explains the concept of a controlling terminal.</p></li><li><p><a href="https://unix.stackexchange.com/a/351064/307410">Does keyboard input always go through a controlling terminal?</a>: Explains some other implications of a controlling terminal.</p></li><li><p><a href="https://github.com/V01D-NULL/limine-terminal-port">Port of the Limine bootloader terminal</a>: Isolated terminal implementation from the Limine bootloader, with basic text-mode rendering.</p></li><li><p><a href="https://wiki.osdev.org/Terminals">OSDev: Terminals</a></p></li><li><p><a href="https://unix.stackexchange.com/q/60641/307410">Linux: Difference between /dev/console , /dev/tty and /dev/tty0</a></p></li><li><p><a href="https://manpages.ubuntu.com/manpages/bionic/man4/vt.4freebsd.html">bionic (4) vt.4freebsd.gz</a>: <code>vt </code>manpage for BSD</p></li><li><p><a href="https://stackoverflow.com/a/44104228">How to read from the terminal "keystrokes buffer"?</a>: A fantastic dive into a particular example of the shell behavior when interacting with the terminal.</p></li></ul><hr><h4>Footnotes</h4><p id="footnote-1"><small><a href="#footnote-1-indicator">1.</a> I originally wrote this in Markdown, and translated it to Pugjs (the templating system I use for my website) using <a href="https://alexandremasy.com/markdown-to-pug/">this tool</a>. Unfortunately, it introduced many errors that I had to hand-correct, so excuse any formatting mistakes here.</small></p><hr><p>&copy; Copyright 2023 Jonathan Lam</p></body></html>