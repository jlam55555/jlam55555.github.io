<!DOCTYPE html><html><head><title>jlam | Understanding the tty subsystem: Overview and architecture</title><style>html {
  box-sizing: border-box;
  margin: 0;
  padding: 0.5rem;
}
body {
  max-width: 400pt;
  margin: 0 auto;
  padding: 0;
}</style><link rel="icon" href="/res/favicon.png"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><h1>Jonathan Lam</h1><p>Core Developer @ Hudson River Trading</p><nav><a href="/">Home</a> | <a href="/contact">Contact</a> | <a href="/experience">Experience</a> | <a href="//github.com/jlam55555/resume/raw/master/resume.pdf" target="_blank">Resume</a> | <a href="/blog">Blog</a></nav><hr><!-- inspiration taken from https://codepen.io/Zoxon/pen/WyqdBb--><!-- styles for blog posts--><style>kbd {
	background-color: #eee;
	padding: 0 3px;
	border: 1px solid black;
	border-radius: 2px;
}
blockquote {
	margin: 0;
	background-color: #eee;
	padding: 1px 1em;
}
li {
	margin-block-start: 1em;
	margin-block-end: 1em;
}
h5 {
	font-size: 1em;
	color: #666;
	margin-bottom: 1em;
}
</style><h2>Blog</h2><h3>Understanding the tty subsystem: Overview and architecture</h3><p>On 4/7/2023, 5:30:04 PM</p><p><a href="/blog">Return to blog</a></p><hr><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-zc7WDnCM3aom2EziyDIRAtQg1mVXLdILE09Bo+aE1xk0AM2c2cVLfSW9NrxE5tKTX44WBY0Z2HClZ05ur9vB6A==" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" integrity="sha512-vswe+cgvic/XBoF1OcM/TeJ2FW0OofqAVdCZiEYkd6dwGXthvkSFWOoGGJgS2CW70VK5dQM5Oh+7ne47s74VTg==" crossorigin="anonymous"><style>pre {
	padding: .5rem !important;
	line-height: 1 !important;
}
code.fancy-code {
	line-height: 1 !important;
	font-size: 0.75rem !important;
	tab-size: 8 !important;
}
</style><p><strong>Preface 04/07/2023</strong>: This is my attempt at understanding terminal devices in Linux, both from a summary perspective and from an implementation perspective (for my OS project). This is the result of roughly two days of frantic Internet searching, and was originally written as part of my OS project documentation<sup id="footnote-1-indicator"><a href="#footnote-1">1</a></sup>.</p><p><strong>Update 05/01/2023</strong>: I've corrected and extended bits of this post after working on <a href="/blog/55">the keyboard driver</a> and better understanding the tty layer. In particular, I've updated parts related to line discipline and the event subsystem.</p><p><strong>Update 05/04/2023</strong>: This blog post was getting too long, so I've split it into two parts. This is part 1, which summarizes the terminal subsystem and goes over its architecture. <a href="/blog/56">Part 2</a> describes the line discipline, which defines the behavior of the terminal device. <a href="/blog/58">Part 3</a> describes two of the buffering data structures used in the tty subsystem.</p><hr><h4>What is a terminal device?</h4><p>The terminal is an abstraction used to manage I/O from a serial device. In its simplest form, let's assume we have a single keyboard, and a non-multitasking computer (only running one process at any time, and this process is in the foreground). Then, the terminal acts as the interface between the user and the process.</p><pre><code class="fancy-code language-text">MASTER SIDE                          SLAVE SIDE
===========                          ==========

              --< output queue <-- (stdout)
      screen /                    \
user <-------       TERMINAL       --> process
    keyboard \                    /
              --> input queue --- (stdin)</code></pre><p>This is all a terminal is. It has a "master" (interactive) and a "slave" (process) side, and two queues (one for input and one for output). The master side can have some additional functionality, such as sending signals to the slave. Like a pipe, both sides can write to the file: output on one side becomes input on the other. In particular, the master side writes keyboard input to the input buffer (queue) and reads from the output buffer (queue) to the screen; the slave side reads from the input buffer (stdin) and writes to the output buffer (stdout).</p><p>In the old days, there were physical terminals (teletype machines, or tty), which were machines used to input data to and display output from mainframes, and the upper and lower lines were two pairs of physical wires (RX/TX). Modern terminals only exist as a software abstraction, but the name tty persists.</p><hr><h4>Virtualization</h4><p>The picture becomes muddier if we consider more complex usage scenarios. This usually involves virtualizing (multiplexing) one of the components in the previous simplified scenario.</p><h5>Multiple serial input devices?</h5><p>Introduce multiple terminal devices. Each terminal is implemented in Linux as a device file (in devfs), and processes can interface with any of these files as if they were regular files. For example, the standard keyboard input may live at <code>/dev/tty*</code>, <a href="https://tldp.org/HOWTO/Serial-HOWTO-10.html">serial ports at <code>/dev/ttyS*</code></a>, USB ports at <code>/dev/USB*</code>, etc.</p><h5>Multiple process sessions for one screen?</h5><p>Multiplex (virtualize) the screen over multiple terminals. The <em>virtual terminal</em> (<code>vt</code>) driver does this, multiplexing the screen over seven different terminals <code>/dev/tty[1-7</code>]), each running their own session (shell). The keyboard is only "connected" to the active terminal session.</p><h5>Multiple processes or multiple devices attached to one terminal?</h5><p>Multiplex the master and/or the slave side of a terminal. The GNU <code>screen</code> utility is the prototypical example of this, turning the single-channel semantics into a broadcast semantics when multiple processes connect to the same terminal device. In other words, input from terminal device(s) should show up in the input buffers for all slave process(es), and output from all slave process(es) should show up on the output buffer for all terminal device(s).</p><h5>Emulated (non-physical) master device?</h5><p>So far, the master side input comes directly from the keyboard (or some other physical serial device) and the output goes directly to the text-mode display. However, it may be useful to have master-side I/O not be connected to a physical device; it will be emulated by software instead. This is called a <em>pseudoterminal</em>, and is provided by the <code>pty</code> driver.</p><p>The standard use case for this is to create a terminal emulator (e.g., <code>xterm</code>) in a graphical environment such as X.org. A graphical application in X.org does not have direct access to physical serial devices (i.e., it cannot add a hook into the driver for the physical device). However, it does have indirect access to event streams through the Linux event subsystem (e.g., at <code>/dev/event*</code> via the <code>evdev</code> input event driver), and X.org will also send input events to the foreground application.</p><p>The way a terminal emulator works is by creating a master/slave terminal device pair by opening the special file <code>/dev/ptmx</code>. Then, it sends keyboard events to the master-side input buffer, and characters read from the master-side output buffer are displayed in the graphical application window.</p><hr><h4>Terminology</h4><p>The words "terminal" and "console" are commonly (ab)used colloquially to mean most, if not all, of the below terms. Since the concept of a terminal or console has changed over time, these terms are somewhat fluid; however, I try to capture my modern interpretation of the terms below.</p><ul><li><p><strong>Terminal</strong>: An abstract device that implements a bidirectional master/slave I/O channel.</p></li><li><p><strong>Physical terminal (tty)</strong>: Refers to a terminal device connected to a physical device, e.g., a serial port; now, "tty" is loosely used to refer to the subsystem in general and to terminal devices in general.</p></li><li><p><strong>Virtual terminal (vt)</strong>: Driver that multiplexes the text-mode display over multiple terminal devices, and performs the text-mode rendering; provides the text-mode terminals usually found at <code>/dev/tty[1-6] </code>or  <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd> through <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F6</kbd>.</p></li><li><p><strong>Console</strong>: Historically, the (system) console was the physical terminal connected to a mainframe. This also handled rendering of terminal output on the screen. Nowadays, I think of the <code>vt</code> interface and the console as one and the same. I also use the term "console driver" to refer to the code that manages the text-mode buffer (rendering text to the screen).</p></li><li><p><strong>System console</strong>: This now usually refers to the text-mode terminal used for kernel logging (i.e., calls to <code>printk()</code> get printed here, and this can usually be found at <code>/dev/tty1</code>).</p></li><li><p><strong>Pseudoterminal (pty)</strong>: Driver that provides a master/slave terminal device file pair; allows the use of software to emulate the terminal master device rather than the master device being implemented in a hardware driver.</p></li><li><p><strong>Terminal emulator</strong> (e.g., <code>xterm</code>): A program running in graphical mode that provides an interface similar to a program running in a text-mode terminal using a pseudoterminal. In some ways, this is the graphical mode equivalent of a virtual terminal, and some people also call these programs virtual terminals.</p></li><li><p><strong>Terminal multiplexer</strong> (e.g., GNU <code>screen</code>): Allow multiple processes to connect to a single terminal device (multi-channel terminal); reads and writes are broadcasted rather than being sent to a single process.</p></li><li><p><strong>Shell</strong> (e.g., <code>bash</code>): An interactive text-mode application that uses a terminal device for I/O; prompts user for commands to run and executes them, displaying their output. The words "shell" and "terminal" are often used erroneously when the other is described.</p></li></ul><hr><h4>Overall architecture</h4><h5>The <code>vt</code> stack</h5><p>The text-mode physical terminals (typically <code>/dev/tty[1-6&rsqb;</code> on Linux) use the <code>vt</code> driver. Keyboard events are sent directly to the <code>vt</code> driver, which are then forwarded to the input buffer of the selected physical terminal. Data written to the output buffer is displayed on the screen using the text-mode console driver. Processes can read from and write to the slave side of the terminal device using the <code>/dev/tty*</code> file interface.</p><pre><code class="fancy-code language-text">Text mode/physical terminal

+---------------+  +-----------------+
| /usr/bin/bash |  | print to screen |
| process       |  | console driver  |
+---------------+  +-----------------+
              ^             ^
 stdin/stdout |             | terminal output buffer
              |             |
+-------------v-------------|---------+
| +--------------+  +---------------+ |
| | /dev/tty5    |  | /dev/tty5     | |
| | slave driver |  | master driver | |
| +--------------+  +---------------+ |
|             vt driver        ^      |
+------------------------------|------+
                               |
               keyboard events |
                               |
                       +-----------------+
                       | /dev/event*     |
                       | input subsystem |
                       +-----------------+
                               ^
                     scancodes |
                               |
                       +---------------+
                       | Keyboard IRQ  |
                       +---------------+</code></pre><h5>The <code>pty</code> stack</h5><p>Terminal emulators use the <code>pty</code> driver to obtain a terminal device (through the <code>/dev/ptmx</code> interface). The terminal emulator application receives keyboard events when it is the foreground application, and forwards these to the master-side input buffer. Data written to the output buffer are displayed in the terminal emulator window. Processes can read from and write to the slave side of the terminal device using the <code>/dev/pts/*</code> file interface.</p><pre><code class="fancy-code language-text">Graphical mode/pseudoterminal

+---------------+           +--------------------+
| /usr/bin/bash |           | /usr/bin/xterm     |
| process       |           | terminal emulator  |
+---------------+           +--------------------+
              ^             ^  |                 ^
 stdin/stdout |    terminal |  | keyboard events |
              |     out buf |  |                 |
+-------------v-------------|--v------+  +-------------+
| +--------------+  +---------------+ |  | X.org event |
| | /dev/pts/3   |  | /dev/ptmx     | |  | layer       |
| | slave driver |  | master driver | |  +-------------+
| +--------------+  +---------------+ |    ^
|             pty driver              |    | keyboard events
+-------------------------------------+    |
                                         +-----------------+
                                         | /dev/event*     |
                                         | input subsystem |
                                         +-----------------+
                                           ^
                                           | scancodes
                                           |
                                         +---------------+
                                         | Keyboard IRQ  |
                                         +---------------+
</code></pre><h5>A unified architecture and the introduction of ldisc</h5><p>In the above diagrams for the <code>vt</code> and <code>pty</code> stacks, we envision the terminal layer as a driver. A driver's purpose is to abstract away hardware to a uniform software interface, so this would be appropriate if a terminal were simply a bidirectional serial channel with no extra semantics associated with it. This is how we've described a terminal so far.</p><p>However, we've been omitting the fact that the terminal <em>does</em> have special semantics associated with it. This functionality gives the terminal a behavior we're all used to today, such as echoing, line editing (canonical mode), and signal handling (e.g., <kbd>Ctrl</kbd>+<kbd>C</kbd> sends SIGTERM). Collectively, we call these <em>line discipline</em>, or <em>ldisc</em> for short.</p><p>Thus, we now envision the terminal layer as two separate entities: the terminal driver (e.g., <code>vt</code> or <code>pty</code>), which provide a uniform interface with master-side serial hardware input and output devices; and the <em>tty core</em> layer or <em>line discipline</em>, which provides a uniform interface for software readers and writers of the terminal. This provides a clear <a href="https://www.oreilly.com/library/view/linux-device-drivers/0596005903/ch01.html">separation of mechanism and policy</a>. The terminal driver provides a uniform interface to forward data from a serial input device to the line discipline, and write output to an output device (whether this be rendering to a text console or writing to a serial device). The line discipline interfaces between the terminal driver and the software slave. This is how an updated architecture might look for the <code>vt</code> driver.</p><pre><code class="fancy-code language-text">+-----------+
| /bin/bash |
| shell     |
+-----------+
  ^
  | stdin/stdout
  v
+------------------------+
| /dev/tty5              |
| character device layer |
| in the filesystem      |
+------------------------+
  ^
  |
+-v-------------------+ slave side
| +-----------------+ |
| | n_tty           | |
| | line discipline | |
| +-----------------+ |
|    ^                |
|    |                | tty layer
|    v                |
| +-----------------+ |
| | vt              | |
| | terminal driver | |
| +-----------------+ |
+-^----------------\--+ master side
  |                 \
  | keyboard events  \ terminal output
  |                   v
+-----------------+  +----------------+
| keyboard driver |  | console driver |
+-----------------+  +----------------+</code></pre><p>For the pseudoterminal case, we replace the <code>vt</code> driver with <code>pty</code> driver, and the master "hardware" devices are actually software sources.</p><p>I explore the line discipline in <a href="/blog/56">part 2</a> of this blog post.</p><hr><h4>Terminal driver design</h4><p>For this section, we consider the case of a stereotypical <code>vt</code>-like terminal driver, which reads input from the keyboard and renders output to a screen. Sample code for the <code>vt</code> driver can be found in <code>drivers/tty/vt/*.c</code>.</p><h5>Terminal driver interface</h5><p>The terminal driver interface comprises one major interface: a <code>write()</code> function called by the line discipline to write output to the device. This is defined by the <struct>tty_operations</struct> data structure in <code>include/linux/tty_driver.h</code>.</p><p>Notably, we do not need to provide a <code>read()</code> interface; instead, any event generated by the input device should call the line discipline's <code>receive_input()</code> interface. In Linux, the tty core will manage buffering through the use of the <a href="https://www.oreilly.com/library/view/linux-device-drivers/0596005903/ch18.html">flip buffer data structure</a>, so the driver need not concern itself with this.</p><h5>Keyboard input driver</h5><p>The goal of <a href="/blog/55">the keyboard driver and input subsystem</a> is to provide a sequence of keyboard events for applications to use. Each keyboard event may contain information such as timestamp, type of event (keydown, keypress (repeat), or keyup), keycode, the state of keyboard modifiers and toggle keys (e.g., <kbd>Shft</kbd>, <kbd>Ctrl</kbd>, <kbd>CapsLock</kbd>, etc.) and ASCII value.</p><p>For the purposes of the terminal, we only care about keydown and keypress events; keyup events are discarded.</p><p>The terminal also only cares about the sequence of ASCII values generated by the keys. Most keyboard events will have an ASCII value associated with it. Some examples (assuming a QWERTY keyboard layout):</p><ul><li>Pressing only the <kbd>A</kbd> key will generate the ASCII value 0x61 ('a').</li><li>Pressing the <kbd>Shft</kbd>+<kbd>A</kbd> key combination will generate the ASCII value 0x41 ('A').</li><li>Pressing the <kbd>Ctrl</kbd>+<kbd>A</kbd> key combination will generate the ASCII value 0x01 (<kbd>^A</kbd><sup id="footnote-2-indicator"><a href="#footnote-2">2</a></sup>).</li></ul><p>The keyboard driver or input subsystem will use the modifier keys to generate an appropriate ASCII value. Sometimes, keys will not be associated with an ASCII value, such as the left cursor arrow key or the <kbd>Insert</kbd> key; these may be generate multi-byte escape sequences (beginning with the escape byte <kbd>^[</kbd>). If only modifier keys are pressed, no ASCII sequence is generated.</p><p>A terminal driver such as <code>vt</code> or <code>pty</code> that takes a stream of keyboard events must transform it into a stream of ASCII characters to send to the line discipline.</p><h5>Text console output driver</h5><p>The console driver should be able to display text to the screen. In the simplest case, the BIOS graphics mode is set to VGA text mode, and text is rendered by writing to a character buffer at a fixed offset.</p><p>The console should probably manage a scrollback buffer used to back the video memory buffer, and implement scrolling once the cursor moves past the bottom of the screen. Additionally, scrolling may be implemented if the scrollback buffer is taller than the screen height.</p><p>Most characters will be printable characters in the range of ASCII 0x20-0x1F. However, some characters, notably <kbd>^J</kbd> (line feed) moves the cursor down one row; <kbd>^M</kbd> (carriage return) moves the cursor to the beginning of the line; and <kbd>^H</kbd> (backspace) moves the cursor to the left, unless it is already at the left edge of the screen. How other nonprintable characters and non-ASCII characters (characters with the parity bit set) should be printed is up to the console.</p><p>A more advanced console driver should be able to handle additional drawing features and perform more efficient rendering. In particular, most terminals support the VT100 (ANSI) escape codes, which are multi-byte sequences that begin with the escape character <kbd>^[</kbd> that perform actions such as changing the text or background color. I don't know much about efficient rendering, but I imagine it means to defer work as necessary (as I imagine rendering can be an expensive operation, even for text).</p><hr><h4>In the Linux kernel</h4><h5>Use cases of tty</h5><p>The tty interface can be used whenever you have a situation similar to the motivating scenario. We've already covered the classic <code>vt</code> and <code>pty</code> driver examples. Other prototypical examples include the <code>ssh</code> and <code>telnet</code> programs, which are interactive sessions to some external computer. In this case, the slave process is not a local process, but rather a shell process (<code>ssh</code>) or some process writing to a port (<code>telnet</code>) on a remote machine.</p><h5>Source code</h5><ul><li><p><code>include/linux/tty.h</code>: Defines essential data structures related to a tty device, such as <code>struct tty_struct</code>.</p></li><li><p><code>include/linux/tty_driver.h</code>: Defines essential data structures for a tty driver implementer (such as vt and pty), such as <code>struct tty_driver</code> and <code>struct tty_operations</code>. These define the interface for a terminal driver.</p></li><li><p><code>drivers/tty/vt/vt.c</code>: Defines a <code>struct tty_driver</code> for the six multiplexed text-mode physical terminal devices; provides the <code>/dev/tty*</code> slave device files. See also <code>drivers/tty/vt/vc_screen.c</code>, which performs the text-mode rendering, and <code>drivers/tty/vt/keyboard.c</code>, which handles keyboard input.</p></li><li><p><code>drivers/tty/pty.c</code>: Defines a <code>struct tty_driver</code> for the <code>/dev/ptmx</code> and <code>/dev/pts/*</code> master/slave device files.</p></li></ul><hr><h4>Resources</h4><ul><li><p><a href="http://www.linusakesson.net/programming/tty/">The TTY demystified</a>: Highly recommended by many people. Provides a general overview of the tty subsystem, and especially talks about line discipline and signals.</p></li><li><p><a href="https://unix.stackexchange.com/q/117981/307410">What are the responsibilities of each Pseudo-Terminal (PTY) component (software, master side, slave side)?</a>: Many fantastic answers about tty in general, line discipline, and the pty master/slave relationship.</p></li><li><p><a href="https://www.reddit.com/r/osdev/comments/hgzg6k/comment/fwabf1j/?utm_source=reddit&amp;utm_medium=web2x&amp;context=3">TTY questions</a>: Some considerations when designing a tty implementation.</p></li><li><p><a href="https://stackoverflow.com/q/24024985/2397327">Linux keyboard/terminal/kernel input buffer</a>: Motivates a terminal multiplexer like GNU <code>screen</code>.</p></li><li><p><a href="https://stackoverflow.com/q/48627344/2397327">Linux keyboard/terminal/kernel input buffer</a>: Another Internet user trying to figure out how the tty subsystem works.</p></li><li><p><a href="https://unix.stackexchange.com/a/138390/307410">How to read/write to tty* device?</a>: Provides some examples of how to use <code>/dev/tty </code>files.</p></li><li><p><a href="https://unix.stackexchange.com/q/21147/307410">What are pseudo terminals (pty/tty)?</a>: Gives a simple explanation of pty.</p></li><li><p><a href="https://unix.stackexchange.com/q/404555/307410">What is the purpose of the controlling terminal?</a>: Explains the concept of a controlling terminal.</p></li><li><p><a href="https://unix.stackexchange.com/a/351064/307410">Does keyboard input always go through a controlling terminal?</a>: Explains some other implications of a controlling terminal.</p></li><li><p><a href="https://github.com/V01D-NULL/limine-terminal-port">Port of the Limine bootloader terminal</a>: Isolated terminal implementation from the Limine bootloader, with basic text-mode rendering.</p></li><li><p><a href="https://wiki.osdev.org/Terminals">OSDev: Terminals</a></p></li><li><p><a href="https://unix.stackexchange.com/q/60641/307410">Linux: Difference between /dev/console , /dev/tty and /dev/tty0</a></p></li><li><p><a href="https://manpages.ubuntu.com/manpages/bionic/man4/vt.4freebsd.html">bionic (4) vt.4freebsd.gz</a>: <code>vt </code>manpage for BSD</p></li><li><a href="https://blog.robertelder.org/detect-keyup-event-linux-terminal/">Why Is It so Hard to Detect Keyup Event on Linux?</a></li><li><a href="https://man7.org/linux/man-pages/man4/console_codes.4.html"><code>console_codes(4)</code></a></li><li><a href="https://stackoverflow.com/questions/4842424/list-of-ansi-color-escape-sequences">List of ANSI color escape sequences</a></li><li><a href="https://docs.kernel.org/driver-api/tty/index.html">TTY driver API</a></li><li><a href="https://www.oreilly.com/library/view/linux-device-drivers/0596005903/ch18.html">Linux Device Drivers Chapter 18: TTY drivers</a></li></ul><hr><h4>Footnotes</h4><p id="footnote-1"><small><a href="#footnote-1-indicator">1.</a> I originally wrote this in Markdown, and translated it to Pugjs (the templating system I use for my website) using <a href="https://alexandremasy.com/markdown-to-pug/">this tool</a>. Unfortunately, it introduced many errors that I had to hand-correct, so excuse any formatting mistakes here.</small></p><p id="footnote-2"><small><a href="#footnote-2-indicator">2.</a> I used the Emacs notation here, where <kbd>^X</kbd> indicates <kbd>Ctrl</kbd>+<kbd>X</kbd>.</small></p><hr><p>&copy; Copyright 2023 Jonathan Lam</p></body></html>