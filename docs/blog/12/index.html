<!DOCTYPE html><html><head><title>jlam | First thoughts on Emacs</title><style>html {
	box-sizing: border-box;
	margin: 0;
	padding: 0.5rem;
}
body {
	max-width: 400pt;
	margin: 0 auto;
	padding: 0;
}</style><link rel="icon" href="/res/favicon.png"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><h1>Jonathan Lam</h1><p>EE/CS @ The Cooper Union</p><nav><a href="/">Home</a> | <a href="/contact">Contact</a> | <a href="/experience">Experience</a> | <a href="/res/resume.pdf" target="_blank">Resume</a> | <a href="http://files.lambdalambda.ninja">Files</a> | <a href="/blog">Blog</a></nav><hr><!-- inspiration taken from https://codepen.io/Zoxon/pen/WyqdBb--><h2>Blog</h2><h3>First thoughts on Emacs</h3><p>On 5/23/2021, 8:09:53 PM</p><p><a href="/blog">Return to blog</a></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-zc7WDnCM3aom2EziyDIRAtQg1mVXLdILE09Bo+aE1xk0AM2c2cVLfSW9NrxE5tKTX44WBY0Z2HClZ05ur9vB6A==" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" integrity="sha512-vswe+cgvic/XBoF1OcM/TeJ2FW0OofqAVdCZiEYkd6dwGXthvkSFWOoGGJgS2CW70VK5dQM5Oh+7ne47s74VTg==" crossorigin="anonymous"><style>pre {
	padding: .5rem !important;
	line-height: 1 !important;
}
code {
	line-height: 1 !important;
	font-size: 0.75rem !important;
	tab-size: 8 !important;
}
</style><p>I've been a casual ViM user for some time now (6 years?), and it's a great experience. I love to work in the terminal and I love to type, and it worked fast on my first laptop when full IDEs were too painfully slow. The command mode and the movement keys are quickly intuitive, and you only have to learn a few major commands to be working efficiently. Of course, IDEs and other software support ViM-like editing and navigation<sup id="footnote-1-indicator"><a href="#footnote-1">1</a></sup>.</p><p>But I have a need to use Scheme Lisp to study <a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">SICP</a>, and it (like many other editors) doesn't historically<sup id="footnote-2-indicator"><a href="#footnote-2">2</a></sup> <sup id="footnote-3-indicator"><a href="#footnote-3">3</a></sup> have advanced support for Lisp. The go-to environment for many Lisp-ers, in the longstanding tradition of GNU and Lisp, is Emacs. It has a popular development environment for CL called SLIME: the Superior Lisp Interaction Mode for Emacs.</p><h4>General reactions</h4><p>My first reaction to Emacs is that it opens in its own window like <code>gvim</code>, even if you call it from a terminal emulator. You can run it in a terminal emulator with the no-window command: <code>emacs -nw</code>, but this may cause some problems<sup id="footnote-4-indicator"><a href="#footnote-4">4</a></sup>.</p><p>My second opinion is captured by Randall Munroe perfectly:</p><a href="https://imgs.xkcd.com/comics/real_programmers.png" target="_blank" title="click to open in new tab"><img src="https://imgs.xkcd.com/comics/real_programmers.png" alt="Obligatory xkcd" style="max-width:100%;"></a><p>Seriously, there are a lot of shortcuts<sup id="footnote-5-indicator"><a href="#footnote-5">5</a></sup>. Some other notes:</p><ul><li>Despite there being many more commands than what ViM has to offer, there are still a number of relatively common operations that I had hoped were easily accessible but require some composition of simpler commands. For example, the ViM command <kbd>o</kbd> (insert new line below the current line and move the cursor to it) is most easily performed out-of-the-box with <kbd>C-c Enter</kbd><sup id="footnote-6-indicator"><a href="#footnote-6">6</a></sup>.</li><li>Watch out for <a href="https://wiki.c2.com/?EmacsPinky">Emacs pinky</a>. It's a real problem as much as other repetitive strain problems like RSI in the wrist. This goes to show how often the command keys are used. Perhaps worse is that many of the commands are not placed in easy-to-reach positions, but rather are given keys corresponding to a command hierarchy and roughly semantic keys -- not having the navigation commands on the homerow really makes me appreciate ViM's navigation system and command mode in general.</li><li>One of the benefits of the roughly semantic key placement is that it is easy to remember (without muscle memory). For example, this makes it easier for me to use it with two different keyboard layouts. (The ViM navigation, on the other hand, completely loses its ergonomic benefit without remapping.)</li><li>Emacs is part of the GNU ecosystem, and many of the commands, especially the navigation commands, are very similar. E.g., the navigation commands in <code>bash</code>, <code>w3m</code>, and <code>info</code> are all the same as Emacs commands. (This has made me much more comfortable with bash.)</li></ul><h4>For the complete beginner</h4><p>The most important resource for the beginner is the tutorial. Luckily, Emacs has a lot of help resources. On first opening Emacs, there's a link to the tutorial, which feels very similar to the <code>vimtutor</code> command. A few notes for the complete beginner:</p><ul><li>Learn the notation right away. Commands are usually in the form of a sequence of keys, often with modifiers. E.g., <kbd>C-h t</kbd> means <kbd>Ctrl</kbd>+<kbd>h</kbd> followed by <kbd>t</kbd> (this opens the tutorial). The Meta key (Alt key) is often also used, for example <kbd>C-M-\</kbd> means <kbd>Ctrl</kbd>+<kbd>Meta</kbd>+<kbd>\</kbd>. (I've already been using this notation throughout this article.)</li><li>Get familiar with the help resources. The help resources mostly begin with <kbd>C-h</kbd>. For example, to learn what a keyboard command does, use <kbd>C-h c [keycombo&rsqb;</kbd>. Each key combination is mapped to an (elisp) command, so this will give the name of the corresponding function. The inverse function is <kbd>C-h w [function&rsqb;</kbd> -- this gives the keyboard combination mapped to this elisp function, if any. To learn more about an function, use <kbd>C-h f [function&rsqb;</kbd>. To learn more about or to set an elisp variable, use <kbd>C-h v [variable&rsqb;</kbd>. To get a list of all help commands, use <kbd>C-h ?</kbd>.</li><li>Similar to the above, learn how to use the Info pages. These are a GNU-backed alternative to the manpages, and deeply tied into Emacs. This can be found using <kbd>C-h i</kbd>, which brings up a version of Info embedded within Emacs. Info has its own tutorial, and many of its navigation commands are similar to Emacs.</li><li>Given how many commands there are, there is also a considerable hierarchy for the commands. The help commands being prefixed with <kbd>C-h</kbd> is one example; another is that file or buffer-related commands are listed under <kbd>C-x</kbd>. Some packages use a common prefix, such as <kbd>C-c</kbd> for SLIME/geiser and <kbd>C-x g</kbd> for magit.</li></ul><h4>Extensibility with elisp</h4><p>Like every good ol' hackable piece of software, Emacs is built upon its own customization DSL, Emacs Lisp (elisp)! No other piece of software comes close with such a complete scripting language dedicated for its customization -- vimscript and other languages with the same purpose feel awfully narrow-minded in comparison. You can even write standalone scripts in elisp, as it is a regular Lisp.<sup id="footnote-7-indicator"><a href="#footnote-7">7</a></sup></p><p>I hinted at the existence of elisp before when mentioning that every keyboard shortcut is mapped to a function in elisp. In this way, Emacs just feels like a program written in elisp, and the behavior of the program can be changed and extended by changing or adding more elisp. Due to the interpreted nature of Lisp, it is trivial to add new code to a running program, and thus to add new packages or modify elisp code on the fly.</p><p>Many elisp functions can be called from the editor directly, either by a keyboard shortcut or equivalently by using <kbd>M-x [command&rsqb;</kbd><sup id="footnote-8-indicator"><a href="#footnote-8">8</a></sup>. (Recall that you can find the function corresponding to a keyboard shortcut and vice versa using <kbd>C-h c [keycombo&rsqb;</kbd> and <kbd>C-h w [command&rsqb;</kbd>, respectively.) There are some functions (e.g., helper functions) that cannot be called directly from the editor; functions that can be called directly from the editor have to be declared interactive. There are also many variables that can be used to customize features and packages.</p><p>One place you'll probably end up writing elisp code is the <code>~/.emacs</code> file, which is run on Emacs startup. Other elisp code can be found in Emacs and package files with the <code>.el</code> extension that are located in the <code>load-path</code> variable.</p><h4>The package experience</h4><p>The packages are great. Installing these few packages really makes me feel the extensibility of Emacs.</p><p>Before mentioning any of these packages, I'd first like to make a note about modes in Emacs. When editing a buffer (file), you always have a major mode equipped, as well as any number of minor modes. The major mode dictates the general type of the buffer -- for example, there are major modes for file types like Lisp, LaTeX, Term (for a terminal buffer created with <code>M-x term</code>), and a generic catchall major mode called Fundamental. A minor mode implements a feature that can be toggled on/off independently of other major and minor modes. Examples include the <code>fci-mode</code> (for a column indicator similar to ViM's colorcolumn) and <code>linum-mode</code> (for line numbers). The major and a subset of the minor modes<sup id="footnote-9-indicator"><a href="#footnote-9">9</a></sup> are shown in the modeline at the bottom of the Emacs window (just above the minibuffer). The mode string is indicated in parentheses, and may look something like:</p><pre><code class="language-">(Scheme Chicken Paredit/A)
(Lisp Paredit adoc SLIME)
(Fundamental)
</code></pre><p>The most obvious effect of installing a new package is that it introduces new major and/or minor modes. Below I'll list the few that I got started with. My particular use case was that I wanted a development environment for Scheme (for <em>SICP</em>) and CL (for <em>Practical Common Lisp</em>).</p><p>The other thing to know before getting started with packages in Emacs is how to get them. Emacs supports ELPA (Emacs Lisp Package Archive) packages, which usually come from two major repositories: GnuELPA (enabled by default) and MELPA (has to be added manually). All of the packages listed below come from MELPA. To add MELPA to the list of package reporitories, you'll want to add the following to your Emacs config file (<code>~/.emacs</code>):</p><pre><code class="language-elisp">(require 'package)
(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/"))
</code></pre><p>With the config file buffer still open, do <code>M-x ev-b</code> to run the file (eval buffer), <code>M-x package-refresh-contents</code> to fetch the package lists from the MELPA repository, and <code>M-x package-install RET [package&#93; RET</code> to install a package.</p><h5>SLIME and geiser</h5><p>SLIME -- the Superior Lisp Interaction Mode for Emacs -- lives up to its (flamboyant) name. It introduces a REPL major mode and several minor modes that makes Emacs really feel like an IDE rather than just a text editor: you can easily switch between the REPL and the buffer, autodoc symbols as you type them, evaluate the current definition under your cursor, etc. It feels really slick and I haven't encountered any bugs yet.</p><p>geiser is the Scheme equivalent of SLIME. Like SLIME, it supports several variants of the Scheme (Chez, Chibi, Chicken, Gambit, Gauche, Guile, Kawa, MIT, Racket, and Sktlos). I was using Chez and my experience was mixed -- there seems to be problems with using Geiser's compliation functions for latest version of Chez (9.5.4) so I had to install 9.4. Even then, there are still some problems when compiling a script after entering debug mode, but this goes away after restarting the REPL. It's manageable at least. The latest versions of Chicken Scheme and Guile Scheme, which I also had installed on my computer, seemed to work OOTB without a problem, but I didn't do anything in depth outside of with Chez.</p><h5>ParEdit</h5><p>You can't do be efficient in Lisp without a good way to manage your parens. ParEdit introduces a minor mode for "performing structured editing of S-expression data." This means that your parens will always<sup id="footnote-10-indicator"><a href="#footnote-10">10</a></sup> be balanced! As opposed to the sloppy method of having dangling, broken parens as you work, this method is defensive and also allows you to perform "structural navigation" through sexprs, such as moving forward or backward over one complete sexpr. (It also works on square and curly braces, quotes, and even has the <code>paredit-comment-dwim</code> smart commenting tool!)</p><p>It really feels like magic once you start using it, and the associated terminology (<a href="https://www.emacswiki.org/emacs/ParEdit#h5o-6">"slurpage and barfage"</a>) feels magical too.</p><h5>Magit</h5><p>I've used this package for one day and it already feels like a Magical Git. Considering how much I already love the git CLI, I was surprised I could love something more. When you enter the Magit major mode, my gut reaction is it feels ViM-like with its single letter commands (e.g., <kbd>c</kbd> for commit or <kbd>s</kbd> to stage), and yet it's able to show you multiple buffers easily and neatly using ediff, which has all of Emacs's navigational and buffer-management utilities. Now I can do <code>git status</code> even more frequently than I could before simply by opening the magit buffer.</p><h4>Closing remarks</h4><p>One thing I didn't mention at all was the Emacs-ViM rivalry. It didn't come up at all from Internet searches when I was learning Emacs commands. On the contrary, I didn't see any mention of ViM except when explicitly searching for Emacs equivalents of certain ViM commands (perhaps this is closer to the nature of the rivalry?). There is a ViM emulation mode for Emacs called <a href="https://github.com/emacs-evil/evil">Evil</a>, whose name is a suggestive of the rivalry but the purpose indicates that ViM has some goods that Emacs can use. Converely, as mentioned in an earlier footnote, there have also been attempts to bring some of Emacs to ViM, such as the ports of SLIME. The rivalry seems good-natured at the very least.</p><p>Even with ViM, which is relatively simple, I was still learning new shortcuts or tricks every now and then for six years. With Emacs, I think I can count on learning how to become more productive for an entire lifetime. Moreover, many actions are still uncomfortable today but I feel somewhat confident that with some time, this discomfort can all be scripted away in elisp or shortcuts can be found through practice.</p><p>It's early to tell, but I think I'll really like Emacs. It's been a steep learning curve, and I expect there to continue to be a steep learning curve, but the number of cool and efficiency-boosting features in this little piece of software is incredible. I think the coolest thing is to be able to have major modes for non-text buffers (such as Magit or the SLIME REPL), which allows you to interact with and navigate many different programs as if they were files.<sup id="footnote-11-indicator"><a href="#footnote-11">11</a></sup> Details like <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Shift-Selection.html">shift-selection</a> and image support, which ViM misses, makes Emacs feel like it lies on the boundary between text editor and full-blown IDE.</p><p id="footnote-1"><sup><a href="#footnote-1-indicator">1.</a> Most IDEs have plugins for ViM-mode editing; the hjkl-navigation system works on Google Drive and jk-scrolling is common in system utilities like less or man; people have created many applications, like <a href="https://www.qutebrowser.org/">qutebrowser</a> with ViM-bindings</sup></p><p id="footnote-2"><sup><a href="#footnote-2-indicator">2.</a> In this world of abundant software, people have of course filled the void; there are ViM equivalents of many of the SLIME environment (see <a href="https://susam.in/blog/lisp-in-vim-with-slimv-or-vlime/">slimv and vlime</a>, but I wanted to try my hand at the acclaimed SLIME (and Emacs in general).</sup></p><p id="footnote-3"><sup><a href="#footnote-3-indicator">3.</a> The only dedicated Lisp editor I know of is DrRacket for Racket and Schemes</sup></p><p id="footnote-4"><sup><a href="#footnote-4-indicator">4.</a> In particular, Emac's key bindings may overlap with that of the terminal emulator. I noticed this immediately with <kbd>C-h</kbd>, which is the prefix for all of the help commands in Emacs, but is linked to the Backspace character in xterm. You can make make <kbd>C-h</kbd> (<kbd>Bksp</kbd>) act as a regular backspace using <code>M-x normal-erase-is-backspace-mode</code>, but then you lose the backspace ability. There's probably another way to get around this (fiddling with your terminal settings to unassociate Backspace and <kbd>C-h</kbd>?) but I haven't found out yet. YMMV -- I notice that I don't have this problem in xfce4-terminal (another GUI-mode terminal emulator) or in the virtual terminals (the text-mode terminals <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd> through <kbd>Ctrl</kbd>+Alt</kbd>+<kbd>F6</kbd>). I figure it's easier to avoid the trouble and use the dedicated Emacs window.</sup></p><p id="footnote-5"><sup><a href="#footnote-5-indicator">5.</a> Two fun commands I discovered while writing this post are <code>M-x eww</code> and <code>M-x m</code>. You know, when you want to send your code as mail or open Stack Overflow in Emacs. Eww can even display images!</sup></p><p id="footnote-6"><sup><a href="#footnote-6-indicator">6.</a> As far as I know, without explicitly mapping the command to some key combination.</sup></p><p id="footnote-7"><sup><a href="#footnote-7-indicator">7.</a> Some popular IDEs do allow for extensions via plugins, such as Atom (JS) and JetBrains IDEs (Kotlin). Emacs still has some leg up just because of how deeply elisp is integrated and how much can be customized, and because Lisp allows updating elisp code while emacs is running. However, the enormous community and industry support for plugins in these more mainstream editors makes them better to get more efficient in a short amount of time.</sup></p><p id="footnote-8"><sup><a href="#footnote-8-indicator">8.</a> When you press <kbd>M-x</kbd>, the cursor appears in an area called the <em>minibuffer</em> at the bottom of the Emacs window, right underneath the <em>modeline</em>.</sup></p><p id="footnote-9"><sup><a href="#footnote-9-indicator">9.</a> Since there are usually many minor modes enabled by default, many are hidden, such as <code>fci-mode</code> and <code>linum-mode</code>. Only "major" minor modes are shown, i.e., the ones you install via packages.</sup></p><p id="footnote-10"><sup><a href="#footnote-10-indicator">10.</a> Most commands when paredit is enabled won't let you break the balanced-ness of your parens, <a href="https://stackoverflow.com/a/26248310/2397327"><code>kill-region</code> and <code>quoted-insert</code> can either break or fix your parens while in paredit mode</a>.</sup></p><p id="footnote-11"><sup><a href="#footnote-11-indicator">11.</a> Perhaps this is another manifestation of the "everything is a file" from Unix philosophy?</sup></p><hr><p>&copy; Copyright 2021 Jonathan Lam</p></body></html>