<!DOCTYPE html><html><head><title>jlam | SICP notes: streams</title><style>html {
	box-sizing: border-box;
	margin: 0;
	padding: 0.5rem;
}
body {
	max-width: 400pt;
	margin: 0 auto;
	padding: 0;
}</style><link rel="icon" href="/res/favicon.png"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><h1>Jonathan Lam</h1><p>EE/CS @ The Cooper Union</p><nav><a href="/">Home</a> | <a href="/contact">Contact</a> | <a href="/experience">Experience</a> | <a href="/res/resume.pdf" target="_blank">Resume</a> | <a href="http://files.lambdalambda.ninja">Files</a> | <a href="/blog">Blog</a></nav><hr><!-- inspiration taken from https://codepen.io/Zoxon/pen/WyqdBb--><!-- styles for blog posts--><style>kbd {
	background-color: #eee;
	padding: 0 3px;
	border: 1px solid black;
	border-radius: 2px;
}
blockquote {
	margin: 0;
	background-color: #eee;
	padding: 1px 1em;
}
li {
	margin-block-start: 1em;
	margin-block-end: 1em;
}
</style><h2>Blog</h2><h3>SICP notes: streams</h3><p>On 7/7/2021, 9:49:33 PM</p><p><a href="/blog">Return to blog</a></p><hr><p>Section 3.5 of <em>SICP</em> is about streams, and I found this section absolutely fascinating (after never really understanding what a stream was). Incidentally, I happened to start reading <em>A Gentle Introduction to Haskell</em> at the same time as reading this section, and it is extremely satisfying to see the idea of laziness coincide.</p><p>Firstly, a quick review of the current place in <em>SICP</em>: chapter 1 covered procedural abstractions, chapter 2 covered data abstractions, sections 3.1-3 covered mutable state and the environment model (essentially imperative programming and how closures can be implemented), and section 3.4 covers concurrency. I think 3.4 is hastily thrown in, and it's also awkward because we aren't given the Scheme primitives to be able to implement the locking primitives. The only provided implementation is an implementation of <code>test-and-set!</code> on a uniprocessor; this would fail on a multiprocessor system (which most computers are nowadays, in which <code>test-and-set!</code> would normally be implemented as a hardware instruction (requiring a memory arbiter). 3.4 covers a lot of concurrency problems and approaches in summary, e.g., deadlocks and avoidance, memory barriers, "serializers" (what Java calls <code>synchronized</code> methods and what Tanenbaum calls "monitors" in <em>Modern Operating Systems</em>), locking primitives, and more. My opinion is that this material is better suited for a class in operating systems or distributed computing, and that the authors only hastily foisted it in here to demonstrate that imperative programming with mutation causes problems in the concurrent sense, or more generally, that introducing "time" into programs and variables, may be problematic. This also ties into the next section, in which streams are used to address the concurrency problem, as streams are "timeless."</p><p> </p><p>TODO: two criticisms of this section: esieve and no macros</p><hr><p>&copy; Copyright 2021 Jonathan Lam</p></body></html>