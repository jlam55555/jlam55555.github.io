<!DOCTYPE html><html><head><title>jlam | SICP notes: streams</title><style>html {
	box-sizing: border-box;
	margin: 0;
	padding: 0.5rem;
}
body {
	max-width: 400pt;
	margin: 0 auto;
	padding: 0;
}</style><link rel="icon" href="/res/favicon.png"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><h1>Jonathan Lam</h1><p>EE/CS @ The Cooper Union</p><nav><a href="/">Home</a> | <a href="/contact">Contact</a> | <a href="/experience">Experience</a> | <a href="/res/resume.pdf" target="_blank">Resume</a> | <a href="http://files.lambdalambda.ninja">Files</a> | <a href="/blog">Blog</a></nav><hr><!-- inspiration taken from https://codepen.io/Zoxon/pen/WyqdBb--><!-- styles for blog posts--><style>kbd {
	background-color: #eee;
	padding: 0 3px;
	border: 1px solid black;
	border-radius: 2px;
}
blockquote {
	margin: 0;
	background-color: #eee;
	padding: 1px 1em;
}
li {
	margin-block-start: 1em;
	margin-block-end: 1em;
}
</style><h2>Blog</h2><h3>SICP notes: streams</h3><p>On 7/7/2021, 9:49:33 PM</p><p><a href="/blog">Return to blog</a></p><hr><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-zc7WDnCM3aom2EziyDIRAtQg1mVXLdILE09Bo+aE1xk0AM2c2cVLfSW9NrxE5tKTX44WBY0Z2HClZ05ur9vB6A==" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" integrity="sha512-vswe+cgvic/XBoF1OcM/TeJ2FW0OofqAVdCZiEYkd6dwGXthvkSFWOoGGJgS2CW70VK5dQM5Oh+7ne47s74VTg==" crossorigin="anonymous"><style>pre {
	padding: .5rem !important;
	line-height: 1 !important;
}
code.fancy-code {
	line-height: 1 !important;
	font-size: 0.75rem !important;
	tab-size: 8 !important;
}
</style><p>Section 3.5 of <em>SICP</em> is about streams, and I found this section absolutely fascinating (after never really understanding what a stream was). Incidentally, I happened to start reading <em>A Gentle Introduction to Haskell</em> at the same time as reading this section, and it is extremely satisfying to see the idea of laziness coincide.</p><p>Firstly, a quick review of the current place in <em>SICP</em>: chapter 1 covered procedural abstractions, chapter 2 covered data abstractions, sections 3.1-3 covered mutable state and the environment model (essentially imperative programming and how closures can be implemented), and section 3.4 covers concurrency. I think 3.4 is hastily thrown in, and it's also awkward because we aren't given the Scheme primitives to be able to implement the locking primitives. The only provided implementation is an implementation of <code>test-and-set!</code> on a uniprocessor; this would fail on a multiprocessor system (which most computers are nowadays, in which <code>test-and-set!</code> would normally be implemented as a hardware instruction (requiring a memory arbiter). 3.4 covers a lot of concurrency problems and approaches in summary, e.g., deadlocks and avoidance, memory barriers, "serializers" (what Java calls <code>synchronized</code> methods and what Tanenbaum calls "monitors" in <em>Modern Operating Systems</em>), locking primitives, and more. My opinion is that this material is better suited for a class in operating systems or distributed computing, and that the authors only hastily foisted it in here to demonstrate that imperative programming with mutation causes problems in the concurrent sense, or more generally, that introducing "time" into programs and variables, may be problematic. This also ties into the next section, in which streams are used to address the concurrency problem, as streams are "timeless."</p><p>Okay, back to streams.</p><hr><h4>Motivation for streams</h4><p>We've done a lot with LISt Processing in LISP. Many of our algorithms are performed on lists or arrays of data, and often we only access data sequentially. Sometimes we can formulate this as a loop (or as tail-call recursion in Scheme), but sometimes the algorithm is more easily formulated as a list operation (e.g., map, filter, reduce) or aggregate expression (e.g., sum, max) on some meaningful list of data (e.g., the integers from 1 to 100, the Fibonacci numbers). Sometimes these sequences are common infinite sequences, and you want to only need to get values on some condition (e.g., integers up to 2 million, the first 50 prime numbers).</p><p>I tried to think of a creative example, but the example given in the book is great, if a little unrealistic. The proposed problem is to get the second prime in an interval. The naive way to do this, using list operations, is to generate the whole interval as a list, filter it for primes, and then choose the second value. But this generates an awfully large number of primes for which all but two (the first two) are important, and we may run of of memory if the interval is too large. An alternative approach is using iteration, but this is messy and we have to encode our logic into the loop.</p><p>The imperative programmer will probably think that the loop formulation is natural and efficient, but the functional programmer sees that using composable list operations is more readable and modular and not inefficient. But efficiency does become a problem when dealing with large lists, especially in cases when we do not use the entirety of the list, because the list operations we know (e.g., map, filter) take the entire list as input, process the whole list, and then return either a new list or an aggregate value as output. The more operations used, and the larger the size of the unused list, the worse the performance. An infinite list would be impossible both in time and memory.</p><hr><h4>Benefits of streams</h4><p>This is where streams come in: we think of our algorithm as two operations: filtering by primes, and then retrieving the second value of the returned list. Ordinarily there may be many more operations in between. Since the input interval is arbitrarily large, we can think of it as infinite for our purposes. What we want to achieve is to only get as many primes as we need for this operation (2, as we want the second prime), and only get as many integers as we need (as many integers in the interval such that we retrieve two primes). In the example above, the second prime after 10000 is 10009, so we only need nine integers out of the input interval.</p><p>An additional goal is to interleave the operation, so that we do not have to store the intermediate lists all in memory at one time. Consider a modified scenario, in which we perform N separate <code>map</code> operations before filtering by primes and getting the second element. Imagine that in this scenario, we need M elements of the input interval, rather than nine, before finding the second prime. Then, between each <code>map</code> operation, we generate an M-element list. If we can find a way to interleave the <code>map</code> operations (which we can do by composing the mapped functions, but imagine that we mixed in different operations like <code>map</code> and <code>filter</code> which cannot be combined into a single list operation), then we only need to store N elements concurrently in memory rather than M. (M is much larger than N.) Note that this doesn't decrease the number of operations, but it decreases the memory requirement.</p><p>To achieve these (related) goals, we make the process "lazy": each of the intermediate lists only yield the next element "on demand." Another way to think of it is by working backwards: we know that we need exactly two primes, so we "ask" for two values from the primes list. The primes array then "asks" for elements of the integer list one at a time until we get two primes (asks 9 times). If there were more steps in this process, this "asking" process would continue. These "lazy" lists are then called streams. If we only "ask" for one value at a time from some list and have this "ask" propagate as needed in order to get the next value of that list, then the operations are naturally interleaved.</p><p>These "lazy" lists are called "streams," and they are beautiful. We get (roughly) the performance of iteration and the elegance of chaining modular operations. We can operate on infinite lists, because we only get as many values as needed; and operations are interleaved, which means that the used values of the streams can be discarded after use<sup id="footnote-1-indicator"><a href="#footnote-1">1</a></sup>.</p><p>If the practical side doesn't wow you, then perhaps you'll appreciate the observation that we can represent infinite data structures, or how simple it is to implement streams, or the power of only a few generic, composable stream operations, or the concision of implicit definitions of infinite streams.</p><hr><h4>Stream implementation</h4><p>Of course, we can't use regular lists to implement a stream. Unlike other languages where lazy evaluation is implemented by default<sup id="footnote-2-indicator"><a href="#footnote-2">2</a></sup>, function parameters are evaluated in full before invoking the function (applicative order evaluation).</p><p>What we need to implement a stream is delayed evaluation. We want to be able to "ask" for the next element of a stream without calculating the rest of the list. This is actually not hard: we can make each <code>cdr</code> of each <code>cons</code> in the list a thunk (a procedure that takes no arguments -- simply an expression that we can call later) that returns the next <code>cons</code>, which is of the same form. Thus each node of the linked list can be thought of as having a value cell and a "pointer function" (rather than a pointer) that gets the next stream element when needed.</p><p>While expressing streams by wrapping the <code>cdr</code>'s in thunks works, it may be inconvenient for the user and more intuitive to express the stream like a normal list. Fortunately, in Lisp we have metaprogramming! We can use a simple macro to rewrite the <code>cdr</code> into a thunk when creating the list using <code>cons</code><sup id="footnote-3-indicator"><a href="#footnote-3">3</a></sup>.</p><pre><code class="fancy-code language-scheme">(define-syntax stream-cons
  ;; rewrite b into a thunk without evaluating it
  ;; for performance we would probably also want to memoize
  ;; the result in case it is used multiple times
  (syntax-rules ()
    ([_ a b]
     (cons a (lambda () b)))))
</code></pre><p>The rest of the stream primitives are fairly straightforward. Retrieving the next element of the list involves evaluating the <code>cdr</code> thunk.</p><pre><code class="fancy-code language-scheme">(define *empty-stream* '())
(define stream-null? null?)
(define stream-car car)
(define (stream-cdr s) ((cdr s)))
</code></pre><p>Actually, you can see that <code>stream-null?</code> and <code>stream-car</code> are exactly the same as they are for normal lists. The only changes occur in the pieces related to the <code>cdr</code>.</p><p>To be explicit, you can see that the definition of <code>stream-cdr</code> is equivalent to invoking the <code>cdr</code> thunk:</p><pre><code class="fancy-code language-scheme">(define (invoke t) (t))
(define stream-cdr (compose invoke cdr))
</code></pre><hr><h4>Stream operations and their implementations</h4><p>We can start by writing an operation akin to <code>list-ref</code> that gets the n-th element of a stream.</p><pre><code class="fancy-code language-scheme">(define (stream-ref s n)
  ;; get the nth value of a stream
  (if [<= n 0]
      (stream-car s)
      (stream-ref (stream-cdr s) (1- n))))
</code></pre><p>We can define the typical list operations that produce another list, like <code>filter</code>, <code>map</code>, <code>zip</code>, <code>running-sum</code>, etc. just like we would with lists except that we use our new <code>stream-*</code> primitives.</p><p>TODO: implementation of filter and map</p><p>The same is true of aggregate operations that produce a single value, such as <code>sum</code>, <code>max</code>, <code>fold-left</code>/<code>fold-right</code>, etc.</p><p>TODO: show an implementation</p><p>Additionally, we may want to introduce certain operations that limit a stream. For example, the <em>take</em> operation returns a stream of a given length. We can also introduce a <em>take-while</em> operation that ends the stream when the predicate is not met. (Think of a filter operation, but it ends the stream when encountering a false value rather than dropping the element.) Similarly, we can discard elements of a stream so that we don't get values from the beginning of the stream. For this, we can introduce the <code>skip</code> and <code>skip-while</code> operators.</p><p>TODO: show an implementation</p><hr><h4>Terminal vs. non-terminal stream operations</h4><p>There are two types of stream operations (operations that take a stream as input): terminal and non-terminal (intermediate) operations. Non-terminal stream operations return another stream and allow you to chain and interleave streams and are thus lazy. Terminal stream operations do not output a stream, and are thus not lazy.</p><p>It is easy to tell what is an intermediate expression and what is not, because intermediate operations can composed in a "chain" and terminal operations can only appear at the end of a "chain"<sup id="footnote-4-indicator"><a href="#footnote-4">4</a></sup>. If we use the example from the book, we can now calculate the result efficiently in terms of stream operations (we will define the interval stream later):</p><pre><code class="fancy-code language-scheme">(stream-ref (stream-filter prime? (stream-interval 10000 100000)))
</code></pre><p>In this case, <code>stream-filter</code> is an intermediate operation and <code>stream-ref</code> is a terminal one.</p><p>In the previous section, the operations that take an input stream and output another stream (e.g., <code>stream-map</code>, <code>stream-filter</code>, <code>stream-zip</code>) are lazy and thus non-terminal. When "asked" for a value, they lazily process their input stream in order to produce the next value. On the other hand, the operations that output some sort of aggregate value (e.g., <code>stream-fold-left</code>/<code>stream-fold-right</code>, <code>stream-sum</code>, <code>stream-ref</code>) must evaluate the entire stream before returning their aggregate value, and thus the input stream to these functions should be finite. We usually don't use streams directly, but usually use some aggregated value that is the result of a terminal operation.</p><p>Other examples of terminal operations, whose implementations are shown below, are <code>stream->list</code>, which converts a stream to a regular list, or <code>stream-for-each</code>, which eagerly loops through a stream.</p><p>TODO: show implementations here</p><hr><h4>Explicit and implicit stream definitions</h4><hr><h4>Scheme metaprogrammed-lists vs. Haskell lists vs. Java <code>Stream</code>s vs. Javascript (RxJS)</h4><hr><hp>Concurrent processing and race conditions</hp><hr><h4>Philosophy: modeling with time in the memory dimension</h4><hr><p>esieve...</p><p>----------</p><p>terminal vs non-terminal operations</p><p>garbage collection</p><p>using macros (versus using lambdas -- macros offer an efficiency that you can't have in other languages)</p><p>haskell vs scheme laziness</p><p>TODO: two criticisms of this section: esieve and no macros</p><p>modeling things using streams rather than using imperative programming (random number generator, history)</p><p>concurrent processing and race conditions</p><p>philosophical: timelessness (extending in the memory dimension rather than the time dimension)</p><hr><h4>Footnotes</h4><p id="footnote-1"><small><a href="#footnote-1-indicator">1.</a> Theoretically, but this will be performed by the garbage collector and the memory reclamation will not be perfect. I tested this out on infinite streams with Chez Scheme, and the garbage collection couldn't keep up with the "garbage disposal."</small></p><p id="footnote-2"><small><a href="#footnote-2-indicator">2.</a> e.g., Haskell, where laziness is the norm and strictness is optional.</small></p><p id="footnote-3"><small><a href="#footnote-3-indicator">3.</a> SICP states that the delayed evaluation is achieved by wrapping the code in thunks, but does not mention macros even though this seems the obvious solution. I don't know why.</small></p><p id="footnote-4"><small><a href="#footnote-4-indicator">4.</a> Sometimes this "chain" of stream expressions is referred to as a pipe, as it is in the Javascript RxJS library, but for us it is simply function composition.</small></p><hr><p>&copy; Copyright 2021 Jonathan Lam</p></body></html>