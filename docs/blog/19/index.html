<!DOCTYPE html><html><head><title>jlam | SICP notes: a simple type system</title><style>html {
	box-sizing: border-box;
	margin: 0;
	padding: 0.5rem;
}
body {
	max-width: 400pt;
	margin: 0 auto;
	padding: 0;
}</style><link rel="icon" href="/res/favicon.png"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><h1>Jonathan Lam</h1><p>EE/CS @ The Cooper Union</p><nav><a href="/">Home</a> | <a href="/contact">Contact</a> | <a href="/experience">Experience</a> | <a href="/res/resume.pdf" target="_blank">Resume</a> | <a href="http://files.lambdalambda.ninja">Files</a> | <a href="/blog">Blog</a></nav><hr><!-- inspiration taken from https://codepen.io/Zoxon/pen/WyqdBb--><!-- styles for blog posts--><style>kbd {
	background-color: #eee;
	padding: 0 3px;
	border: 1px solid black;
	border-radius: 2px;
}
blockquote {
	margin: 0;
	background-color: #eee;
	padding: 1px 1em;
}
li {
	margin-block-start: 1em;
	margin-block-end: 1em;
}
h5 {
	font-size: 1em;
	color: #666;
	margin-bottom: 1em;
}
</style><h2>Blog</h2><h3>SICP notes: a simple type system</h3><p>On 6/12/2021, 4:32:16 PM</p><p><a href="/blog">Return to blog</a></p><hr><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-zc7WDnCM3aom2EziyDIRAtQg1mVXLdILE09Bo+aE1xk0AM2c2cVLfSW9NrxE5tKTX44WBY0Z2HClZ05ur9vB6A==" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" integrity="sha512-vswe+cgvic/XBoF1OcM/TeJ2FW0OofqAVdCZiEYkd6dwGXthvkSFWOoGGJgS2CW70VK5dQM5Oh+7ne47s74VTg==" crossorigin="anonymous"><style>pre {
	padding: .5rem !important;
	line-height: 1 !important;
}
code.fancy-code {
	line-height: 1 !important;
	font-size: 0.75rem !important;
	tab-size: 8 !important;
}
</style><p>(Based on reading 2.4-5 of SICP)</p><p>Chapter 2 of SICP moved quickly. Sections 2.1-3 were relatively straightforward: they introduce the idea of complex data and data abstractions, with plenty of interesting examples<sup id="footnote-1-indicator"><a href="#footnote-1">1</a></sup>. But it felt a little same-old-same-old: we start from the basics and build up from there. We did it with procedures, now we do it with data, so it was more interesting in the first chapter<sup id="footnote-2-indicator"><a href="#footnote-2">2</a></sup>. But in the latter two sections of the chapter, there were many ideas that snuck in before I knew they were happening. So I'll use this space to sort out my thoughts.</p><h4>Introducing polymorphism</h4><p>In Section 2.3, we were introduced to the concept of using symbols to "tag" data with type information. </p><pre><code class="fancy-code language-scheme">(define (tag-attach type-tag contents)
  ;; attach a tag to a datum
  (cons type-tag contents))

(define (tag-type datum)
  ;; type selector for a tagged datum
  (if [pair? datum]
      (car datum)
      (error 'tag-type "bad tagged datum" datum)))

(define (tag-contents datum)
  ;; contents selector for a tagged datum
  (if [pair? datum]
      (cdr datum)
      (error 'tag-contents "bad tagged datum" datum)))</code></pre><p>This allows us to "box"<sup id="footnote-3-indicator"><a href="#footnote-3">3</a></sup> any value into an "object" with an attached "type." When processing the boxed object, we extract (unbox) the value. Objects can then be boxed into more complicated objects to form more complex typed objects. For example, one example we see in section 2.5 is a pair that gets interpreted as a complex number in rectangular form, which is then tagged a second time as a complex number to hide the internal details to the generic arithmetic package. This object would look like</p><pre><code class="fancy-code language-scheme">'(2 . 3)</code></pre><to>the rectangular complex arithmetic package,</to><pre><code class="fancy-code language-scheme">'(rectangular . (2 . 3))</code></pre><p>to the complex arithmetic package, and</p><pre><code class="fancy-code language-scheme">'(complex . (rectangular . (2 . 3)))</code></pre><p>to the generic arithmetic package. This boxing/unboxing	is a powerful abstraction technique.</p><p>With type information, we can act upon heterogeneous data with the same interface. This is useful in 2.3 when we have a function that recursively deals with trees: we need to differentiate between an internal tree node and a leaf node in the Huffman encoding example. In this example, we require only two types to effectively deal with trees, and we can simply switch on the data type to perform the needed action.</p><p>However, things quickly get more complicated. Section 2.4 is called "Multiple representations of abstract data." Previously, we had already observed that most data structures can be defined by the interface they present, rather than its internal representation: a <code>cons</code> requires a <code>car</code> and <code>cdr</code> interface, but it can be implemented straightforwardly as a record or by using closures. SICP uses the example of complex numbers, because the two common representations -- a (real, imaginary) rectangular representation, or a (magnitude, angle) polar representation -- are both practical: for example, addition is easier with the first representation and multiplication with the latter.</p><p>The main question raised by this section is: how can we support both implementations at once with a single interface? We want the implementation-dependent interface to be:</p><pre><code class="fancy-code language-scheme">(make-cplx-from-real-imag x y)
(make-cplx-from-mag-ang r a)
(cplx-real-part z)
(cplx-imag-part z)
(cplx-magnitude z)
(cplx-angle z)</code></pre><p>This creates an abstraction barrier upon which we can define operations (a higher-level interface) on complex numbers that depend only on these selectors, and not on the internal representation. For example, the basic arithmetic operations can be defined like so:</p><pre><code class="fancy-code language-scheme">(define (cplx+ z1 z2)
  (make-cplx-from-real-imag (+ (cplx-real-part z1)
                               (cplx-real-part z2))
                            (+ (cplx-imag-part z1)
			       (cplx-imag-part z2))))</code></pre><p>and likewise for the other operators. Up until now, we only have one "version" of each function. We would implement <code>cplx-real-part</code> based on some internal representation or another. We could hot-swap different internal representations by redefining all of the implementation-dependent interface procedures. But this only allows us to have one implementation of a data structure to be in use at a time. But, as mentioned earlier, we may find it useful to have different internal implementations share the same interface. In other words, we want to introduce <em>polymorphism</em>: <code>cplx-real-part</code> should call the rectangular version if applied to a complex number implemented using the rectangular representation, and likewise for the polar implementation.</p><p>Since we can't actually define multiple versions of a procedure in Scheme<sup id="footnote-4-indicator"><a href="#footnote-4">4</a></sup>, we have to emulate one. The simplest method is to attach a type to each parameter (we do this using the tagging mention mentioned earlier) and switch on the argument type.</p><pre><code class="fancy-code language-scheme">(define (cplx-real-part z)
  (cond ([eq? (tag-type z) 'rectangular]
	 (cplx-real-part-rectangular (tag-contents z)))
	([eq? (tag-type z) 'polar]
	 (cplx-real-part-polar (contents z)))
	(else
	 (error cplx-real-part "Unknown type" (tag-type z))))</code></pre><p>This works, but it's inconvenient and brittle. We have to write out the conditional in every function, and if we wanted to add another internal representation of a complex number, we'd have to redefine the whole procedure with the longer conditional.</p><p>A better solution is a dispatching system. For each generic procedure, we still need to write an version for each internal implementation. If the procedure takes multiple arguments, then we need one version for each permutation of (argument) types that we need to support<sup id="footnote-5-indicator"><a href="#footnote-5">5</a></sup> We store all of these versions in a table, indexed by the argument types they support. We do this for every generic procedure, and store all these procedure versions in a lookup table indexed by the generic procedure type and the supported argument types. Then the process of invoking a polymorphic procedure involves the looking up and calling the specific implementation required for this set of arguments.</p><p>I want to include the code, but there's too much to include here. You can refer to the book or my notes (<a href="https://github.com/jlam55555/sicp/blob/master/2.4/2.4.scm">2.4</a>; <a href="https://github.com/jlam55555/sicp/blob/master/2.5/2.5.scm">2.5</a>).</p><p>Out of this system, we can <em>additively</em> extend this system with new operations or data types by adding the appropriate entries to the lookup table. This is as opposed to having to redefine the existing procedure in order to modify it (i.e., by hardcoding the new entry into the conditional statement).</p><h4>Extending this system to procedures with multiple arguments</h4><p>We now begin section 2.5: "Systems with generic operations," which builds upon this lookup-table model. In 2.4, we built up the complex number interface using two different representations of complex numbers. In 2.5, we have a more complex system: an arithmetic interface with multiple representations of algebraic structures (reals, rationals, complex numbers, polynomials, and rational functions). The base idea is mostly the same, but we introduce binary operators like <code>add</code> and <code>sub</code> that can plausibly take parameters of different algebraic structure types (e.g., a real and a complex).</p><p>The naive approach to take is to define an implementation for each permutation of argument types (this was briefly mentioned earlier). However, this leads to disaster if the function supports multiple arguments that can be of multiple types. Even a binary procedure, in which each of the arguments can be one of N types, requires O(N^2) different implementations. In general, the growth rate of the number of implementations to write is O(N^M), where the function is M-ary.</p><p>A second approach is to define a set of type <em>coercions</em>. A coercion is an implicit conversion from one type to another, and can be implemented as an ordinary procedure that is stored in the lookup table<sup id="footnote-6-indicator"><a href="#footnote-6">6</a></sup>. If a procedure is called with arguments that don't exactly match the argument list, the dispatcher will look for available coercions to change the argument lists into a suitable type. We may still need to write a coercion between every pair of types that can be converted to one another, but this is only O(N^2) with respect to the number of types N.</p><p>To those accustomed to object-oriented programming, this may still seem silly. It may seem natural to define a hierarchy on types so that we have natural type conversions (upcasting). This makes sense if there is some sort of hierarchy, but it gets messier when multiple inheritance is allowed. If we allowed this, we may need to search an entire graph rather than a (linear) hierarchy to find the correct implementation.</p><h4>Aside: data-directed programming vs. message passing</h4><p>SICP notes that while the method we've built up of "dispatch operation based on data" (<em>"data-driven programming"</em>) is very powerful, it is not the only way to support an extensible, polymorphic interface. Instead, we can dispatch a <em>datum</em> with an action. Here is the example provided:</p><pre><code class="fancy-code language-scheme">(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
	  ((eq? op 'imag-part) y)
	  ((eq? op 'magnitude)
	   (sqrt (+ (square x) (square y))))
	  ((eq? op 'angle) (atan y x))
	  (else
	   (error "Unknown op -- MAKE-FROM-REAL-IMAG" op))))
  dispatch)</code></pre><p>We can then "call" the datum with the operation we want to perform on it. This "dispatch datum based on operation" method is called <em>"message passing"</em> -- to call a "method" on an "object," we "pass" the "object" a "message": the operation to perform<sup id="footnote-7-indicator"><a href="#footnote-7">7</a></sup>. We already saw this method when implementing <code>cons</code> with a procedural implementation (message passing <em>is</em> the procedural implementation).</p><p>Honestly, I'm not sure when this would be most useful, and I don't know of any languages that use this as a default mode for dispatch.</p><h4>The big picture</h4><p>Why is this important? What have we achieved?</p><p>We've developed a simple typing system in a language that does not enforce typing. And we were able to configure this typing from the bottom up, without any constraints imposed by the language (e.g., without a builtin OOP framework). We can attach types to data, and interpret those types as we are processing the data.</p><p>In particular, we created a simple polymorphic framework that allows type coercion. While we usually hear about polymorphism in the context of OOP, there is no mention of it here, nor do we say that one form of inheritance is best -- they are simply not the full picture. There is no single best way to implement typing, as the authors note in a footnote:</p><blockquote><p>Developing a useful, general framework for expressing the relations among different types of entities (what philosophers call ``ontology'') seems intractably difficult. The main difference between the confusion that existed ten years ago and the confusion that exists now is that now a variety of inadequate ontological theories have been embodied in a plethora of correspondingly inadequate programming languages. For example, much of the complexity of object-oriented programming languages -- and the subtle and confusing differences among contemporary object-oriented languages -- centers on the treatment of generic operations on interrelated types. Our own discussion of computational objects in chapter 3 avoids these issues entirely. Readers familiar with object-oriented programming will notice that we have much to say in chapter 3 about local state, but we do not even mention ``classes'' or ``inheritance.'' In fact, we suspect that these problems cannot be adequately addressed in terms of computer-language design alone, without also drawing on work in knowledge representation and automated reasoning.</p></blockquote><p>In some of the most popular OOP languages like C++, Java, and Python, we have multiple inheritance and single-dispatch polymorphism, but that is not the only way to do things. For example, in our system we implement (a very simple form of) multiple-dispatch polymorphism. We can mess around with the features of the topology graph even when it isn't allowed (e.g., multiple subclassing isn't allowed in Java, but we can try to allow it) in a different language. We can use message passing as the underlying implementation for OOP and see what benefits it has to offer. And we have access to all of Lisp's best features, such as its powerful macro system (to make our own OOP a seamless part of Lisp syntax) and continuations.</p><p>Here is <a href="https://www.gamedev.net/forums/topic/441248-isnt-sicp-just-reinventing-inheritance/3923677/">an illustrative from the gamedev.net forum</a>:</p><blockquote><p>SICP is not about teaching features but general concepts, and Abelson and Sussman obviously don't think typical OO is general enough to qualify as a central concept. So they teach dispatch-on-type, which can easily be used to implement typical object systems, while the converse isn't true (see the need for the visitor and other 'patterns' in typical OO languages).</p><p>Single-dispatch polymorphism and inheritance (python or C++ OO) is a specialised restriction of what is being taught here. Abelson and Sussman aim higher.</p></blockquote><p>Of course, there are some disadvantages when compared to other languages. In languages with builtin OOP support, we can have compile-time and run-time (dynamic) polymorphism, while in Lisp we are limited to the latter. Performance is clearly going to suffer. And those who use other high-level, multi-paradigm languages probably find the claim that Lisp is best suited to this task weak, because it could'be been done in Javascript or Python just as well. It's true -- modern languages have become very flexible and capable of Lisp's expressiveness. My only argument to this is that you will be overly influenced by the typing systems in those languages, and in this manner be limited. Maybe this is a weak argument, but there is no doubt that Lisp is <em>a</em> suitable tool for this task.</p><hr><h4>Footnotes</h4><p id="footnote-1"><small><a href="#footnote-1-indicator">1.</a> Such as: procedural implementation of <code>cons</code>, Church numerals, the picture language, interval arithmetic, the accumulate/filter/map list primitives, a concise n-queens problem built on those primitives, symbolic differentiation, three representations of the set data structure, and Huffman encoding.</small></p><p id="footnote-2"><small><a href="#footnote-2-indicator">2.</a> But part of the author's intention was to show that procedural and data abstractions were not all that different, and in particular show that procedures can act as data, as I've mentioned multiple times prior.</small></p><p id="footnote-3"><small><a href="#footnote-3-indicator">3.</a> Somewhat in the same sense as boxing/unboxing in Java.</small></p><p id="footnote-4"><small><a href="#footnote-4-indicator">4.</a> Because Scheme have typed procedures or method overloading.</small></p><p id="footnote-5"><small><a href="#footnote-5-indicator">5.</a> This, and methods to mitigate how many versions are neede, is discussed later.</small></p><p id="footnote-6"><small><a href="#footnote-6-indicator">6.</a> The authors use a separate lookup table for coercions, but I implemented it using the same lookup table. Conveniently, the lookup table already performs a lookup by two items (operation, argument-types), so we can change the interpretation for the key to be a (to-type, from-type) tuple.</small></p><p id="footnote-7"><small><a href="#footnote-7-indicator">7.</a> There are a lot of air quotes here because I don't know what the formal names are.</small></p><hr><p>&copy; Copyright 2021 Jonathan Lam</p></body></html>