<!DOCTYPE html><html><head><title>jlam | Understanding the tty subsystem: Data structures</title><style>html {
  box-sizing: border-box;
  margin: 0;
  padding: 0.5rem;
}
body {
  max-width: 400pt;
  margin: 0 auto;
  padding: 0;
}</style><link rel="icon" href="/res/favicon.png"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><h1>Jonathan Lam</h1><p>Core Developer @ Hudson River Trading</p><nav><a href="/">Home</a> | <a href="/contact">Contact</a> | <a href="/experience">Experience</a> | <a href="//github.com/jlam55555/resume/raw/master/resume.pdf" target="_blank">Resume</a> | <a href="/blog">Blog</a></nav><hr><!-- inspiration taken from https://codepen.io/Zoxon/pen/WyqdBb--><!-- styles for blog posts--><style>kbd {
	background-color: #eee;
	padding: 0 3px;
	border: 1px solid black;
	border-radius: 2px;
}
blockquote {
	margin: 0;
	background-color: #eee;
	padding: 1px 1em;
}
li {
	margin-block-start: 1em;
	margin-block-end: 1em;
}
h5 {
	font-size: 1em;
	color: #666;
	margin-bottom: 1em;
}
</style><h2>Blog</h2><h3>Understanding the tty subsystem: Data structures</h3><p>On 5/10/2023, 11:12:07 PM</p><p><a href="/blog">Return to blog</a></p><hr><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-zc7WDnCM3aom2EziyDIRAtQg1mVXLdILE09Bo+aE1xk0AM2c2cVLfSW9NrxE5tKTX44WBY0Z2HClZ05ur9vB6A==" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" integrity="sha512-vswe+cgvic/XBoF1OcM/TeJ2FW0OofqAVdCZiEYkd6dwGXthvkSFWOoGGJgS2CW70VK5dQM5Oh+7ne47s74VTg==" crossorigin="anonymous"><style>pre {
	padding: .5rem !important;
	line-height: 1 !important;
}
code.fancy-code {
	line-height: 1 !important;
	font-size: 0.75rem !important;
	tab-size: 8 !important;
}
</style><p>This is part three of the discussion on the tty subsystem (<a href="/blog/54">part 1</a>, <a href="/blog/56">part 2</a>). Here we cover two essential data structures that are useful for providing efficient and reliable buffering<sup id="footnote-1-indicator"><a href="#footnote-1">1</a></sup>.</p><p>Recall the architecture of the tty subsystem for the input path. When the hardware device receives an input event, the tty driver sends this event to the tty line discipline. The process can then read input from the line discipline.</p><p>There are two use cases for buffering. The line discipline may require significant processing, so we may not want to call it directly from the tty driver, which will often be probably in interrupt context. Thus, we require some buffering to quickly store input from the tty driver, and defer the flushing of this buffer to the line discipline outside of interrupt context. This buffering mechanism is implemented using the <em>flip buffer</em> data structure.</p><p>We also require a buffer to store data in the line discipline before it is read by the process. To maximize line size, we use a ringbuffer (fixed-size queue) to implement the <em>line buffer</em>. We also need to handle both raw and canonical mode.</p><p>Both buffering methods are best-effort<sup id="footnote-2-indicator"><a href="#footnote-2">2</a></sup>. If the flip buffers don't get a chance to flush to the line discipline before they fill up, then data is lost before it reaches the line discipline. Similarly, if the line buffer is filled at a rate faster than <code>read()</code>s from the slave process empty it, then data will be lost before it is sent to the process<sup id="footnote-3-indicator"><a href="#footnote-3">3</a></sup>.</p><p>Note that the flip-buffering is an optimization used to keep interrupt-context execution short, whereas the line buffer is necessary to buffer data for subsequent calls to <code>read()</code> on the tty device.</p><hr><h4>Flip buffers</h4><p>Flip buffers provide a simple best-effort mechanism for a producer-consumer queue, with minimal need for synchronization. The idea is that we use two buffers: one for receiving data, and one for reading data<sup id="footnote-4-indicator"><a href="#footnote-4">4</a></sup>. Since the producer and consumer operate on separate arrays, synchronization is minimized (the producer and consumer only need to agree on which buffer is the producer/consumer buffer).</p><p>Input events fill up the producer buffer; once it is full, the producer buffer is marked as full. If the consumer buffer is empty, then we can swap the producer and consumer buffers, so that new input events will go into the new producer buffer (which was previously the consumer buffer), and the consumer will be notified that data is available to read. If the consumer buffer is not empty, then we cannot swap the buffers yet, and any new data will be lost.</p><p>Conversely, the tty ldisc reads from the consumer buffer. Once it is empty, the consumer buffer is marked as empty. If the producer buffer is full, then we can swap the producer and consumer buffers, and the ldisc can continue reading from the new consumer buffer (which was previously the producer buffer).</p><p>Under normal operation, we hope that the consumer can read data from the consumer buffer faster than the producer fills up the new producer buffer, so that we don't have data loss. What actually happens depends heavily on the nature of the serial input device (e.g., producing very intermittent data such as a keyboard device, or a higher-frequency serial device), the size of the flip buffers, and the nature of the consumer (e.g., how much processing goes on in the tty ldisc consumer). The process of "notifying" the consumer that data is available is usually done by scheduling the producer, so scheduling latency will also have to be considered.</p><p>To improve the reliability of flip-buffering, Linux uses more than two flip-buffers. There exists a pool of flip buffers that may be used. One is always chosen as the producer buffer; once the producer buffer is full, it is pushed onto a queue (linked list) of consumer buffers for the consumer to process. Data is only lost if the flip buffer pool is exhausted.</p><p>To see the action of line buffers in action in Linux, it is instructive to look at the <code>flush_to_ldisc()</code> function in <code>drivers/tty/tty_buffer.c</code>. This is the function that asynchronously flushes data to the line discipline when there is data available, and it demonstrates how to walk the buffer chain.</p><hr><h4>Line buffer</h4><p>The line discipline maintains a queue to buffer terminal input before it is read. A ringbuffer is used; any incoming data from the flip buffers is stored at the <em>commit head</em> pointer, and the head pointer is then advanced. Data is read from the <em>read tail</em> pointer. If the buffer is full (<code>head == tail-1</code>), no additional data will be written to the buffer. If the buffer is empty (<code>head == tail</code>), then any calls to <code>read()</code> will block until new data comes in.</p><p>In raw mode, reads occur between at the tail up to the commit head. In canonical mode, we need additional provisions to handle line-editing. To do this, we have another pointer, called the <em>canonical head</em> pointer. This points to the latest newline character (start of the latest line in the header). Characters before this pointer are finalized, so reads now happen until the read tail reach the canonical head. Characters between the canonical head and the commit (raw-mode) head can be edited using line-editing characters such as <kbd>C-?</kbd> (erase last character)  and <kbd>C-U</kbd> (kill whole line).</p><p>It is very instructive to look at the <code>n_tty_receive_buf()</code> and <code>n_tty_read()</code> API functions in <code>drivers/tty/n_tty.c</code>, where the default line discipline is implemented. <code>n_tty_receive_buf()</code> implements the filling of the buffer, and <code>n_tty_read()</code> implements the emptying of the buffer. For example, see the following excerpt, which is called by <code>n_tty_read()</code> in canonical mode:</p><pre><code class="fancy-code language-c">/**
 * canon_copy_from_read_buf	-	copy read data in canonical mode
 * @tty: terminal device
 * @kbp: data
 * @nr: size of data
 *
 * Helper function for n_tty_read(). It is only called when %ICANON is on; it
 * copies one line of input up to and including the line-delimiting character
 * into the result buffer.
 *
 * Note: When termios is changed from non-canonical to canonical mode and the
 * read buffer contains data, n_tty_set_termios() simulates an EOF push (as if
 * C-d were input) _without_ the %DISABLED_CHAR in the buffer. This causes data
 * already processed as input to be immediately available as input although a
 * newline has not been received.
 *
 * Locking:
 *  * called under the %atomic_read_lock mutex
 *  * n_tty_read()/consumer path:
 *	caller holds non-exclusive %termios_rwsem;
 *	read_tail published
 */
static bool canon_copy_from_read_buf(struct tty_struct *tty,
				     unsigned char **kbp,
				     size_t *nr)
{
	struct n_tty_data *ldata = tty->disc_data;
	size_t n, size, more, c;
	size_t eol;
	size_t tail, canon_head;
	int found = 0;

	/* N.B. avoid overrun if nr == 0 */
	if (!*nr)
		return false;

	canon_head = smp_load_acquire(&ldata->canon_head);
	n = min(*nr, canon_head - ldata->read_tail);

	tail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);
	size = min_t(size_t, tail + n, N_TTY_BUF_SIZE);

	n_tty_trace("%s: nr:%zu tail:%zu n:%zu size:%zu\n",
		    __func__, *nr, tail, n, size);

	eol = find_next_bit(ldata->read_flags, size, tail);
	more = n - (size - tail);
	if (eol == N_TTY_BUF_SIZE && more) {
		/* scan wrapped without finding set bit */
		eol = find_first_bit(ldata->read_flags, more);
		found = eol != more;
	} else
		found = eol != size;

	n = eol - tail;
	if (n > N_TTY_BUF_SIZE)
		n += N_TTY_BUF_SIZE;
	c = n + found;

	if (!found || read_buf(ldata, eol) != __DISABLED_CHAR)
		n = c;

	n_tty_trace("%s: eol:%zu found:%d n:%zu c:%zu tail:%zu more:%zu\n",
		    __func__, eol, found, n, c, tail, more);

	tty_copy(tty, *kbp, tail, n);
	*kbp += n;
	*nr -= n;

	if (found)
		clear_bit(eol, ldata->read_flags);
	smp_store_release(&ldata->read_tail, ldata->read_tail + c);

	if (found) {
		if (!ldata->push)
			ldata->line_start = ldata->read_tail;
		else
			ldata->push = 0;
		tty_audit_push();
		return false;
	}

	/* No EOL found - do a continuation retry if there is more data */
	return ldata->read_tail != canon_head;
}
</code></pre><p>Breaking this down...</p><ol><li><code>canon_head = smp_load_acquire(&ldata->canon_head);</code> Get the current (published<sup id="footnote-5-indicator"><a href="#footnote-5">5</a></sup>) canonical head pointer.</li><li><code>n = min(*nr, canon_head - ldata->read_tail);</code> We assign <code>n</code> to be the number of number of bytes we read. This is the minimum of the requested bytes (<code>*nr</code>) and the available bytes in the line buffer (<code>canon_head - read_tail</code>). Note that the <code>canon_head</code> and <code>read_tail</code> variables are actually monotonic integers and do not wrap around, so the difference should always be positive. We get their positions in the line buffer by using a <code>0xfff</code> mask (since the line buffer is 4096 bytes).</li><li><code>tail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);</code> Perform the masking as described above to get the tail pointer's position in the line buffer.</li><li><code>size = min_t(size_t, tail + n, N_TTY_BUF_SIZE);</code> The end of the read operation, assuming no wraparound. We will deal with the wraparound shortly.</li><li><code>eol = find_next_bit(ldata->read_flags, size, tail);</code> Get the position of the first newline in the range <code>&lsqb;tail, size&rsqb;</code>. Newlines are marked using the <code>ldata->read_flags</code> bitmap. We need to know this because we return at maximum one line at a time in canonical mode. If there is wraparound and we haven't found the end of the line, we look for it in the wrapped portion (this comes a few lines later).</li><li><code>more = n - (size - tail);</code> <code>(size-tail)</code> is the size of the unwrapped bytes to read. <code>more</code> is the size of the wrapped bytes to read.</li><li><code>found = ...;</code> <code>found</code> is true iff a newline is found in the first <code>n</code> bytes. The definition of <code>found</code> depends on whether a newline was found in the unwrapped section or in the wrapped section.</li><li><code>n = eol - tail;</code> If we've found a newline character in the first <code>n</code> bytes, stop reading at that newline character. (If <code>found</code> is false, then <code>eol == size+more</code> and the value of <code>n</code> shouldn't change.)</li><li><code>if (n > N_TTY_BUF_SIZE) n += N_TTY_BUF_SIZE;</code> If there was wraparound, then <code>n</code> will be negative, hence this correction. We check if it is <code>> N_TTY_BUF_SIZE</code> rather than checking if it is less than zero because <code>n</code> is an unsigned integer.</li><li><code>c = n + found;</code> <code>c</code> is the number of bytes to be removed from the buffer, including the newline (if <code>found</code>).</li><li><code>tty_copy(tty, *kbp, tail, n);</code> Perform a ringbuffer copy from <code>tail</code> with length <code>n</code> to the output buffer <code>*kbp</code>.</li><li><code>*kbp += n;</code> Update the position of the pointer in the output buffer.</li><li><code>*nr -= n;</code> Update the number of bytes remaining from the originally requested read size.</li><li><code>if (found) clear_bit(eol, ldata->read_flags);</code> Clear the newline from the bitmap (if <code>found</code>).</li><li><code>smp_store_release(&ldata->read_tail, ldata->read_tail + c);</code> Update the read tail pointer, discarding the next <code>c</code> bytes. Publish this using acquire-release semantics.</li><li><code>return ldata->read_tail != canon_head;</code> Returns <code>true</code> iff there is more data to be read.</li></ol><hr><h4>In the Linux kernel</h4><ul><li><code>include/linux/tty_buffer.h</code>: Flip buffer definitions. See <code>struct tty_buffer</code> (single flip buffer), <code>struct tty_bufhead</code> (list of flip buffers; the <code>struct work_struct</code> field is the deferred buffer flushing operation.)</li><li><code>include/linux/tty_flip.h</code>: Interface between tty driver and flip buffers.</li><li><code>drivers/tty/tty_buffer.c</code>: Flip buffer implementation code.</li><li><code>drivers/tty/n_tty.c</code>: Line discipline and line buffer implementation.</li></ul><hr><h4>Resources</h4><ul><li><a href="https://www.oreilly.com/library/view/linux-device-drivers/0596005903/ch18.html">Linux Device Drivers: TTY Drivers</a>: The O'Reilly book gives the motivation behind tty flip buffers.</li></ul><hr><h4>Footnotes</h4><p id="footnote-1"><small><a href="#footnote-1-indicator">1.</a> I wanted to write about this because I had trouble understanding the design and implementation of both of these data structures. I was only able to find vague explanations of them online. Reading the Linux source code gave me a much more concrete understanding of the data structures, and I hope to summarize what I learned here for those in the same position as me.</small></p><p id="footnote-2"><small><a href="#footnote-2-indicator">2.</a> The input path must be best-effort because we cannot the producer can't sleep if the consumer can't keep up. On the output path, the producer can sleep or defer output if the output buffer is currently full.</small></p><p id="footnote-3"><small><a href="#footnote-3-indicator">3.</a> Data loss also happens if the line length is longer than the line buffer size in canonical mode, but this is a byproduct of the canonical mode protocol.</small></p><p id="footnote-4"><small><a href="#footnote-4-indicator">4.</a> This sounds like the <a href="https://en.wikipedia.org/wiki/Multiple_buffering">multiple buffering</a> technique used in graphics rendering, but the motivation and side-effects are not quite the same. Both involve a separate consumer/producer buffer that allow for parallel producer and consumer action. Multiple buffering is used to reduce visual artifacts due to combining multiple frames in one framebuffer. Flip buffers are used on an inherently serial data stream to reduce latency of the producer code (running in interrupt context). However, loss of coordination between producer and consumer is normal and expected when rendering, causing frame drops; but a slower consumer than producer in the flip buffers causes data loss. Luckily, this is typically tolerable or unlikely for serial devices.</small></p><p id="footnote-5"><small><a href="#footnote-5-indicator">5.</a> An <a href="https://stackoverflow.com/a/24565699/">acquire-release memory ordering model</a> is used here for multi-core synchronization.</small></p><hr><p>&copy; Copyright 2023 Jonathan Lam</p></body></html>