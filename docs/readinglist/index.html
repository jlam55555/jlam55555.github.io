<!DOCTYPE html><html><head><title>jlam | Reading List</title><style>html {
	box-sizing: border-box;
	margin: 0;
	padding: 0.5rem;
}
body {
	max-width: 400pt;
	margin: 0 auto;
	padding: 0;
}</style><link rel="icon" href="/res/favicon.png"><meta name="viewport" content="width=device-width, initial-scale=1.0"></head><body><h1>Jonathan Lam</h1><p>Software Engineer @ Google (Pixel TPU)<br>(Recently) EE/CS @ The Cooper Union</p><nav><a href="/">Home</a> | <a href="/contact">Contact</a> | <a href="/experience">Experience</a> | <a href="//github.com/jlam55555/resume/raw/master/resume.pdf" target="_blank">Resume</a> | <a href="/blog">Blog</a></nav><hr><h2>Reading List</h2><p>I.e., the list of "seems like it'll be useful but I'll probably be too busy to ever get around to reading these for real." Some of these are books I own.</p><p>All of the strange acronyms are verified. I.e., the books should show up on the first page on Google by searching any of the acronyms provided, meaning that I did not make them up. I do like acronyms though.</p><ul><li>Compilers ("Dragon Book")</li><li>FreeBSD Handbook</li><li>R6RS or R7RS</li><li>RE4B ("Understanding Assembly Language")</li><li>CP book</li><li>Phil Oppermann's osdev guide</li><li>CTCI (have access to a hardcopy now!)</li><li>Modern Operating Systems, 2nd Edition (not modern anymore, but I have a hardcopy)</li><li>Algorithm Design (I should've read an algorithms book like this a long time ago)</li><li>Algebra for Applications (wow a math book -- but I do like algebra)</li><li>TAOCP (long-term goal)</li><li>Effective Go</li><li>LYAH</li><li>The Rustonomicon: The Dark Arts of Unsafe Rust</li><li>Foundations for Programming Languages</li></ul><hr><h3>Books in progress</h3><ul><li>Red Book (the database one)</li><li>Program Analysis book (Draft by CMU profs -- for an independent study)</li><li>SICP ("Wizard Book") (haven't read the final chapter) -- favorite book of all time</li><li>The Rust Programming Language (TRPL)</li></ul><hr><h3>Books I've actually read (more or less cover-to-cover)</h3><ul><li>Thomas's Calculus, 12th edition -- college companion for calc 1-4</li><li>K&R -- wonderfully terse</li></ul><hr><h3>Miscellaneous: skills to learn</h3><ul><li>Typing (limitless fun and accessible)<li><strike>Colemak (DH mod) (speeeeeed)</strike> learnt Colemak, not DH due to limited availability</li><li>Dvorak LH (so I can fulfill the unnecessary dream of dual-wielding [keyboards], or just writing with my right hand)</li></li><li><Programming>languages to conquer</Programming><ul><li>Assembly (x86_64/ARM/RISC V) -- RE4B</li><li>Scala (seems like a good general-purpose language)</li><li>Rust (lots of cool features, very fast) -- TRPL, The Rustominicon</li><li>Go (lots of cool features, very fast development) -- Effective Go</li><li>Haskell (pure functional) -- LYAH</li><li>CL/elisp (to become truly powerful)</li><li>Emacs/SLIME (due to the above); also Geiser (like SLIME but for Scheme)</li><li>JavaScript (this language grows too friggin fast, can't keep up with it)</li><li>Swift (was recommended to me by my mentor, creator also created LLVM)</li><li>V (Go syntax/learnibility/compilation speed with Rust runtime performance/no GC)</li></ul></li><li><Other>technologies to conquer</Other><ul><li>LLVM (obvious reasons)</li><li>Some HDL (e.g., Verilog/VHDL)</li><li>Emacs</li></ul></li></ul><hr><p>&copy; Copyright 2023 Jonathan Lam</p></body></html>